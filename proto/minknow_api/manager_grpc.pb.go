// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package minknow

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ManagerServiceClient is the client API for ManagerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ManagerServiceClient interface {
	// Get information about the machine running MinKNOW.
	//
	// Since 3.6
	DescribeHost(ctx context.Context, in *DescribeHostRequest, opts ...grpc.CallOption) (*DescribeHostResponse, error)
	// List all known positions where flow cells can be inserted.
	//
	// Provides a snapshot of places where users can insert flow cells. It has a streamed response
	// in case there are too many positions to fit into a single response, but normally there should
	// only be a single response.
	//
	// Since 3.6
	FlowCellPositions(ctx context.Context, in *FlowCellPositionsRequest, opts ...grpc.CallOption) (ManagerService_FlowCellPositionsClient, error)
	// Watch for changes in flow cell position availability and state.
	//
	// This is like flow_cell_positions, but updates are streamed as positions come and go (eg:
	// MinIONs being plugged or unplugged), or their status otherwise changes.
	//
	// Since 3.6
	WatchFlowCellPositions(ctx context.Context, in *WatchFlowCellPositionsRequest, opts ...grpc.CallOption) (ManagerService_WatchFlowCellPositionsClient, error)
	// Reset a flow cell position.
	//
	// If the hardware is in an error state or has been removed and the software is running, it will
	// stop the software (causing the position to be forgotten if the hardware was removed).
	//
	// If the hardware is not in an error state
	ResetPosition(ctx context.Context, in *ResetPositionRequest, opts ...grpc.CallOption) (*ResetPositionResponse, error)
	// Get the connection information for the basecaller API.
	//
	// This is the service that implements the minknow_api.basecaller interface for basecalling
	// reads files.
	//
	// Since 3.5
	BasecallerApi(ctx context.Context, in *BasecallerApiRequest, opts ...grpc.CallOption) (*BasecallerApiResponse, error)
	// Get information about Guppy, including the port to connect to it on.
	//
	// Since 4.1
	GetGuppyInfo(ctx context.Context, in *GetGuppyInfoRequest, opts ...grpc.CallOption) (*GetGuppyInfoResponse, error)
	// Current version information includes:
	// - Minknow version
	// - Protocols version (i.e. Bream-4 version)
	// - Configuration version (i.e. Wanda version)
	// - Distribution version
	// - Guppy version
	//
	// See also: instance.get_version_info which provides some similar information on a per instance basis.
	// Since 3.3
	GetVersionInfo(ctx context.Context, in *GetVersionInfoRequest, opts ...grpc.CallOption) (*GetVersionInfoResponse, error)
	// Returns all the files that are within the protocol output dir specified in the user_conf - or a descendant of that directory
	// if `path` is supplied in the request.
	//
	// INVALID_ARGUMENT will be returned if the `path` argument in the request is not a descendant of the protocol output directory
	//
	// NOT_FOUND will be returned if the path does not exist. 'The path' being either the protocol output directory if the `path` argument is not specified
	// or a valid `path` argument is specified but does not exist.
	//
	// Since 3.5
	ListProtocolOutputDirFiles(ctx context.Context, in *ListProtocolOutputDirFilesRequest, opts ...grpc.CallOption) (ManagerService_ListProtocolOutputDirFilesClient, error)
	// Create a directory within the protocol output directory tree.
	//
	// Errors:
	//     INVALID_ARGUMENT will be returned if the parent path (where the directory is requested to
	//         be created) is not within the protocol output directory, or if invalid characters are
	//         in the requested directory name.
	//
	//     FAILED_PRECONDITION will be returned if the parent path is not a directory.
	//
	//     NOT_FOUND will be returned if the parent path does not exist.
	//
	//     ALREADY_EXISTS will be returned if the directory exists and is not a directory (if the
	//         directory already exists, this is treated as success).
	//
	// The possible valid parent paths can be determined using list_protocol_output_dir_files().
	//
	// Since 3.6
	CreateDirectory(ctx context.Context, in *CreateDirectoryRequest, opts ...grpc.CallOption) (*CreateDirectoryResponse, error)
	// Returns information about the amount of disk space available, how much
	// space is needed to stop an experiment cleanly and if MinKNOW thinks
	// that the free disk-space is approaching or past this limit
	//
	// Since 3.7
	GetDiskSpaceInfo(ctx context.Context, in *GetDiskSpaceInfoRequest, opts ...grpc.CallOption) (*GetDiskSpaceInfoResponse, error)
	// As with `instance.get_default_output_directories`, this will return the
	// paths that are defined in the config used when an instance of minknow
	// is started.
	//
	// Since 4.3
	GetDefaultOutputDirectories(ctx context.Context, in *GetDefaultOutputDirectoriesRequest, opts ...grpc.CallOption) (*OutputDirectories, error)
	// Stream information about the amount of disk space available, how quickly
	// it is being used, how much space is needed to stop an experiment cleanly
	// and if MinKNOW thinks that the free disk-space is approaching or past
	// this limit
	//
	// Since 4.0
	StreamDiskSpaceInfo(ctx context.Context, in *StreamDiskSpaceInfoRequest, opts ...grpc.CallOption) (ManagerService_StreamDiskSpaceInfoClient, error)
	// Get info about all available barcoding kits
	//
	// Since 4.1
	GetBarcodeKitInfo(ctx context.Context, in *GetBarcodeKitInfoRequest, opts ...grpc.CallOption) (*GetBarcodeKitInfoResponse, error)
	// Get info about all available lamp kits
	//
	// Since 4.1
	GetLampKitInfo(ctx context.Context, in *GetLampKitInfoRequest, opts ...grpc.CallOption) (*GetLampKitInfoResponse, error)
	// List all barcode keys associated with the specified barcoding kits
	//
	// Since 4.1
	GetBarcodeKeys(ctx context.Context, in *GetBarcodeKeysRequest, opts ...grpc.CallOption) (*GetBarcodeKeysResponse, error)
	// List all known types of flow cell.
	//
	// The primary purpose of this RPC is to provide a list of flow cell types for a user to select
	// from (although most flow cells are capable of telling MinKNOW their product code, making user
	// selection unnecessary).
	//
	// A secondary benefit of this call is it allows extra information about flow cell types to be
	// given.
	//
	// Since 4.1
	GetFlowCellTypes(ctx context.Context, in *GetFlowCellTypesRequest, opts ...grpc.CallOption) (*GetFlowCellTypesResponse, error)
	// List all known sequencing kits.
	//
	// The intention is to provide a list of sequencing kits for a user to select from, plus extra
	// information that can be used to filter that list.
	//
	// Since 4.1
	GetSequencingKits(ctx context.Context, in *GetSequencingKitsRequest, opts ...grpc.CallOption) (*GetSequencingKitsResponse, error)
	// Creates a simulated device of the type your system is configured for
	//
	// Since 4.3
	AddSimulatedDevice(ctx context.Context, in *AddSimulatedDeviceRequest, opts ...grpc.CallOption) (*AddSimulatedDeviceResponse, error)
	// Removes a simulated device
	//
	// Since 4.3
	RemoveSimulatedDevice(ctx context.Context, in *RemoveSimulatedDeviceRequest, opts ...grpc.CallOption) (*RemoveSimulatedDeviceResponse, error)
	// Get the path for the local authentication token.
	//
	// This RPC is only useful when connecting to MinKNOW from the same computer that MinKNOW is
	// running on (ie: connecting to "localhost"). If this file exists (which it should if MinKNOW's
	// guest mode is not completely disabled), it contains a description of a token that can be used
	// to connect to MinKNOW. This is most useful when MinKNOW's guest mode is set to "local_only",
	// as it certifies that the client is connecting from the local machine. If the guest mode is
	// set to "enabled", no token is required to connect.
	//
	// The contents of the file is a json object with two fields, "token" and "expires". "token" is
	// the string that can be passed in a "local-auth" gRPC authentication metadata field, while
	// "expires" gives the time the token will expire (in RFC3339 format). Note that a new token
	// will be written out shortly before this time (and, in fact, the token will be accepted a
	// short time after).
	//
	//
	// An example token file is::
	//
	//  {
	//    "token": "30fe5214-a7c5-4cb3-b521-b1ec8a49592a",
	//    "expires": "2020-12-18T14:26:12.021934+00:00"
	//  }
	//
	// To connect before 14:26:12.021934 on 2020-12-18, a client would set the metadata field
	// "local-auth" to "30fe5214-a7c5-4cb3-b521-b1ec8a49592a". At around 14:26:12, the client should
	// re-read the file and update the metadata field with the newly-read value.
	//
	// Since 4.2
	LocalAuthenticationTokenPath(ctx context.Context, in *LocalAuthenticationTokenPathRequest, opts ...grpc.CallOption) (*LocalAuthenticationTokenPathResponse, error)
}

type managerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewManagerServiceClient(cc grpc.ClientConnInterface) ManagerServiceClient {
	return &managerServiceClient{cc}
}

func (c *managerServiceClient) DescribeHost(ctx context.Context, in *DescribeHostRequest, opts ...grpc.CallOption) (*DescribeHostResponse, error) {
	out := new(DescribeHostResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/describe_host", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) FlowCellPositions(ctx context.Context, in *FlowCellPositionsRequest, opts ...grpc.CallOption) (ManagerService_FlowCellPositionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ManagerService_ServiceDesc.Streams[0], "/minknow_api.manager.ManagerService/flow_cell_positions", opts...)
	if err != nil {
		return nil, err
	}
	x := &managerServiceFlowCellPositionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ManagerService_FlowCellPositionsClient interface {
	Recv() (*FlowCellPositionsResponse, error)
	grpc.ClientStream
}

type managerServiceFlowCellPositionsClient struct {
	grpc.ClientStream
}

func (x *managerServiceFlowCellPositionsClient) Recv() (*FlowCellPositionsResponse, error) {
	m := new(FlowCellPositionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *managerServiceClient) WatchFlowCellPositions(ctx context.Context, in *WatchFlowCellPositionsRequest, opts ...grpc.CallOption) (ManagerService_WatchFlowCellPositionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ManagerService_ServiceDesc.Streams[1], "/minknow_api.manager.ManagerService/watch_flow_cell_positions", opts...)
	if err != nil {
		return nil, err
	}
	x := &managerServiceWatchFlowCellPositionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ManagerService_WatchFlowCellPositionsClient interface {
	Recv() (*WatchFlowCellPositionsResponse, error)
	grpc.ClientStream
}

type managerServiceWatchFlowCellPositionsClient struct {
	grpc.ClientStream
}

func (x *managerServiceWatchFlowCellPositionsClient) Recv() (*WatchFlowCellPositionsResponse, error) {
	m := new(WatchFlowCellPositionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *managerServiceClient) ResetPosition(ctx context.Context, in *ResetPositionRequest, opts ...grpc.CallOption) (*ResetPositionResponse, error) {
	out := new(ResetPositionResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/reset_position", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) BasecallerApi(ctx context.Context, in *BasecallerApiRequest, opts ...grpc.CallOption) (*BasecallerApiResponse, error) {
	out := new(BasecallerApiResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/basecaller_api", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) GetGuppyInfo(ctx context.Context, in *GetGuppyInfoRequest, opts ...grpc.CallOption) (*GetGuppyInfoResponse, error) {
	out := new(GetGuppyInfoResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/get_guppy_info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) GetVersionInfo(ctx context.Context, in *GetVersionInfoRequest, opts ...grpc.CallOption) (*GetVersionInfoResponse, error) {
	out := new(GetVersionInfoResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/get_version_info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) ListProtocolOutputDirFiles(ctx context.Context, in *ListProtocolOutputDirFilesRequest, opts ...grpc.CallOption) (ManagerService_ListProtocolOutputDirFilesClient, error) {
	stream, err := c.cc.NewStream(ctx, &ManagerService_ServiceDesc.Streams[2], "/minknow_api.manager.ManagerService/list_protocol_output_dir_files", opts...)
	if err != nil {
		return nil, err
	}
	x := &managerServiceListProtocolOutputDirFilesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ManagerService_ListProtocolOutputDirFilesClient interface {
	Recv() (*ListProtocolOutputDirFilesResponse, error)
	grpc.ClientStream
}

type managerServiceListProtocolOutputDirFilesClient struct {
	grpc.ClientStream
}

func (x *managerServiceListProtocolOutputDirFilesClient) Recv() (*ListProtocolOutputDirFilesResponse, error) {
	m := new(ListProtocolOutputDirFilesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *managerServiceClient) CreateDirectory(ctx context.Context, in *CreateDirectoryRequest, opts ...grpc.CallOption) (*CreateDirectoryResponse, error) {
	out := new(CreateDirectoryResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/create_directory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) GetDiskSpaceInfo(ctx context.Context, in *GetDiskSpaceInfoRequest, opts ...grpc.CallOption) (*GetDiskSpaceInfoResponse, error) {
	out := new(GetDiskSpaceInfoResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/get_disk_space_info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) GetDefaultOutputDirectories(ctx context.Context, in *GetDefaultOutputDirectoriesRequest, opts ...grpc.CallOption) (*OutputDirectories, error) {
	out := new(OutputDirectories)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/get_default_output_directories", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) StreamDiskSpaceInfo(ctx context.Context, in *StreamDiskSpaceInfoRequest, opts ...grpc.CallOption) (ManagerService_StreamDiskSpaceInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &ManagerService_ServiceDesc.Streams[3], "/minknow_api.manager.ManagerService/stream_disk_space_info", opts...)
	if err != nil {
		return nil, err
	}
	x := &managerServiceStreamDiskSpaceInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ManagerService_StreamDiskSpaceInfoClient interface {
	Recv() (*GetDiskSpaceInfoResponse, error)
	grpc.ClientStream
}

type managerServiceStreamDiskSpaceInfoClient struct {
	grpc.ClientStream
}

func (x *managerServiceStreamDiskSpaceInfoClient) Recv() (*GetDiskSpaceInfoResponse, error) {
	m := new(GetDiskSpaceInfoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *managerServiceClient) GetBarcodeKitInfo(ctx context.Context, in *GetBarcodeKitInfoRequest, opts ...grpc.CallOption) (*GetBarcodeKitInfoResponse, error) {
	out := new(GetBarcodeKitInfoResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/get_barcode_kit_info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) GetLampKitInfo(ctx context.Context, in *GetLampKitInfoRequest, opts ...grpc.CallOption) (*GetLampKitInfoResponse, error) {
	out := new(GetLampKitInfoResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/get_lamp_kit_info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) GetBarcodeKeys(ctx context.Context, in *GetBarcodeKeysRequest, opts ...grpc.CallOption) (*GetBarcodeKeysResponse, error) {
	out := new(GetBarcodeKeysResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/get_barcode_keys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) GetFlowCellTypes(ctx context.Context, in *GetFlowCellTypesRequest, opts ...grpc.CallOption) (*GetFlowCellTypesResponse, error) {
	out := new(GetFlowCellTypesResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/get_flow_cell_types", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) GetSequencingKits(ctx context.Context, in *GetSequencingKitsRequest, opts ...grpc.CallOption) (*GetSequencingKitsResponse, error) {
	out := new(GetSequencingKitsResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/get_sequencing_kits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) AddSimulatedDevice(ctx context.Context, in *AddSimulatedDeviceRequest, opts ...grpc.CallOption) (*AddSimulatedDeviceResponse, error) {
	out := new(AddSimulatedDeviceResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/add_simulated_device", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) RemoveSimulatedDevice(ctx context.Context, in *RemoveSimulatedDeviceRequest, opts ...grpc.CallOption) (*RemoveSimulatedDeviceResponse, error) {
	out := new(RemoveSimulatedDeviceResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/remove_simulated_device", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerServiceClient) LocalAuthenticationTokenPath(ctx context.Context, in *LocalAuthenticationTokenPathRequest, opts ...grpc.CallOption) (*LocalAuthenticationTokenPathResponse, error) {
	out := new(LocalAuthenticationTokenPathResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.manager.ManagerService/local_authentication_token_path", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManagerServiceServer is the server API for ManagerService service.
// All implementations must embed UnimplementedManagerServiceServer
// for forward compatibility
type ManagerServiceServer interface {
	// Get information about the machine running MinKNOW.
	//
	// Since 3.6
	DescribeHost(context.Context, *DescribeHostRequest) (*DescribeHostResponse, error)
	// List all known positions where flow cells can be inserted.
	//
	// Provides a snapshot of places where users can insert flow cells. It has a streamed response
	// in case there are too many positions to fit into a single response, but normally there should
	// only be a single response.
	//
	// Since 3.6
	FlowCellPositions(*FlowCellPositionsRequest, ManagerService_FlowCellPositionsServer) error
	// Watch for changes in flow cell position availability and state.
	//
	// This is like flow_cell_positions, but updates are streamed as positions come and go (eg:
	// MinIONs being plugged or unplugged), or their status otherwise changes.
	//
	// Since 3.6
	WatchFlowCellPositions(*WatchFlowCellPositionsRequest, ManagerService_WatchFlowCellPositionsServer) error
	// Reset a flow cell position.
	//
	// If the hardware is in an error state or has been removed and the software is running, it will
	// stop the software (causing the position to be forgotten if the hardware was removed).
	//
	// If the hardware is not in an error state
	ResetPosition(context.Context, *ResetPositionRequest) (*ResetPositionResponse, error)
	// Get the connection information for the basecaller API.
	//
	// This is the service that implements the minknow_api.basecaller interface for basecalling
	// reads files.
	//
	// Since 3.5
	BasecallerApi(context.Context, *BasecallerApiRequest) (*BasecallerApiResponse, error)
	// Get information about Guppy, including the port to connect to it on.
	//
	// Since 4.1
	GetGuppyInfo(context.Context, *GetGuppyInfoRequest) (*GetGuppyInfoResponse, error)
	// Current version information includes:
	// - Minknow version
	// - Protocols version (i.e. Bream-4 version)
	// - Configuration version (i.e. Wanda version)
	// - Distribution version
	// - Guppy version
	//
	// See also: instance.get_version_info which provides some similar information on a per instance basis.
	// Since 3.3
	GetVersionInfo(context.Context, *GetVersionInfoRequest) (*GetVersionInfoResponse, error)
	// Returns all the files that are within the protocol output dir specified in the user_conf - or a descendant of that directory
	// if `path` is supplied in the request.
	//
	// INVALID_ARGUMENT will be returned if the `path` argument in the request is not a descendant of the protocol output directory
	//
	// NOT_FOUND will be returned if the path does not exist. 'The path' being either the protocol output directory if the `path` argument is not specified
	// or a valid `path` argument is specified but does not exist.
	//
	// Since 3.5
	ListProtocolOutputDirFiles(*ListProtocolOutputDirFilesRequest, ManagerService_ListProtocolOutputDirFilesServer) error
	// Create a directory within the protocol output directory tree.
	//
	// Errors:
	//     INVALID_ARGUMENT will be returned if the parent path (where the directory is requested to
	//         be created) is not within the protocol output directory, or if invalid characters are
	//         in the requested directory name.
	//
	//     FAILED_PRECONDITION will be returned if the parent path is not a directory.
	//
	//     NOT_FOUND will be returned if the parent path does not exist.
	//
	//     ALREADY_EXISTS will be returned if the directory exists and is not a directory (if the
	//         directory already exists, this is treated as success).
	//
	// The possible valid parent paths can be determined using list_protocol_output_dir_files().
	//
	// Since 3.6
	CreateDirectory(context.Context, *CreateDirectoryRequest) (*CreateDirectoryResponse, error)
	// Returns information about the amount of disk space available, how much
	// space is needed to stop an experiment cleanly and if MinKNOW thinks
	// that the free disk-space is approaching or past this limit
	//
	// Since 3.7
	GetDiskSpaceInfo(context.Context, *GetDiskSpaceInfoRequest) (*GetDiskSpaceInfoResponse, error)
	// As with `instance.get_default_output_directories`, this will return the
	// paths that are defined in the config used when an instance of minknow
	// is started.
	//
	// Since 4.3
	GetDefaultOutputDirectories(context.Context, *GetDefaultOutputDirectoriesRequest) (*OutputDirectories, error)
	// Stream information about the amount of disk space available, how quickly
	// it is being used, how much space is needed to stop an experiment cleanly
	// and if MinKNOW thinks that the free disk-space is approaching or past
	// this limit
	//
	// Since 4.0
	StreamDiskSpaceInfo(*StreamDiskSpaceInfoRequest, ManagerService_StreamDiskSpaceInfoServer) error
	// Get info about all available barcoding kits
	//
	// Since 4.1
	GetBarcodeKitInfo(context.Context, *GetBarcodeKitInfoRequest) (*GetBarcodeKitInfoResponse, error)
	// Get info about all available lamp kits
	//
	// Since 4.1
	GetLampKitInfo(context.Context, *GetLampKitInfoRequest) (*GetLampKitInfoResponse, error)
	// List all barcode keys associated with the specified barcoding kits
	//
	// Since 4.1
	GetBarcodeKeys(context.Context, *GetBarcodeKeysRequest) (*GetBarcodeKeysResponse, error)
	// List all known types of flow cell.
	//
	// The primary purpose of this RPC is to provide a list of flow cell types for a user to select
	// from (although most flow cells are capable of telling MinKNOW their product code, making user
	// selection unnecessary).
	//
	// A secondary benefit of this call is it allows extra information about flow cell types to be
	// given.
	//
	// Since 4.1
	GetFlowCellTypes(context.Context, *GetFlowCellTypesRequest) (*GetFlowCellTypesResponse, error)
	// List all known sequencing kits.
	//
	// The intention is to provide a list of sequencing kits for a user to select from, plus extra
	// information that can be used to filter that list.
	//
	// Since 4.1
	GetSequencingKits(context.Context, *GetSequencingKitsRequest) (*GetSequencingKitsResponse, error)
	// Creates a simulated device of the type your system is configured for
	//
	// Since 4.3
	AddSimulatedDevice(context.Context, *AddSimulatedDeviceRequest) (*AddSimulatedDeviceResponse, error)
	// Removes a simulated device
	//
	// Since 4.3
	RemoveSimulatedDevice(context.Context, *RemoveSimulatedDeviceRequest) (*RemoveSimulatedDeviceResponse, error)
	// Get the path for the local authentication token.
	//
	// This RPC is only useful when connecting to MinKNOW from the same computer that MinKNOW is
	// running on (ie: connecting to "localhost"). If this file exists (which it should if MinKNOW's
	// guest mode is not completely disabled), it contains a description of a token that can be used
	// to connect to MinKNOW. This is most useful when MinKNOW's guest mode is set to "local_only",
	// as it certifies that the client is connecting from the local machine. If the guest mode is
	// set to "enabled", no token is required to connect.
	//
	// The contents of the file is a json object with two fields, "token" and "expires". "token" is
	// the string that can be passed in a "local-auth" gRPC authentication metadata field, while
	// "expires" gives the time the token will expire (in RFC3339 format). Note that a new token
	// will be written out shortly before this time (and, in fact, the token will be accepted a
	// short time after).
	//
	//
	// An example token file is::
	//
	//  {
	//    "token": "30fe5214-a7c5-4cb3-b521-b1ec8a49592a",
	//    "expires": "2020-12-18T14:26:12.021934+00:00"
	//  }
	//
	// To connect before 14:26:12.021934 on 2020-12-18, a client would set the metadata field
	// "local-auth" to "30fe5214-a7c5-4cb3-b521-b1ec8a49592a". At around 14:26:12, the client should
	// re-read the file and update the metadata field with the newly-read value.
	//
	// Since 4.2
	LocalAuthenticationTokenPath(context.Context, *LocalAuthenticationTokenPathRequest) (*LocalAuthenticationTokenPathResponse, error)
	mustEmbedUnimplementedManagerServiceServer()
}

// UnimplementedManagerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedManagerServiceServer struct {
}

func (UnimplementedManagerServiceServer) DescribeHost(context.Context, *DescribeHostRequest) (*DescribeHostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeHost not implemented")
}
func (UnimplementedManagerServiceServer) FlowCellPositions(*FlowCellPositionsRequest, ManagerService_FlowCellPositionsServer) error {
	return status.Errorf(codes.Unimplemented, "method FlowCellPositions not implemented")
}
func (UnimplementedManagerServiceServer) WatchFlowCellPositions(*WatchFlowCellPositionsRequest, ManagerService_WatchFlowCellPositionsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchFlowCellPositions not implemented")
}
func (UnimplementedManagerServiceServer) ResetPosition(context.Context, *ResetPositionRequest) (*ResetPositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPosition not implemented")
}
func (UnimplementedManagerServiceServer) BasecallerApi(context.Context, *BasecallerApiRequest) (*BasecallerApiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BasecallerApi not implemented")
}
func (UnimplementedManagerServiceServer) GetGuppyInfo(context.Context, *GetGuppyInfoRequest) (*GetGuppyInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGuppyInfo not implemented")
}
func (UnimplementedManagerServiceServer) GetVersionInfo(context.Context, *GetVersionInfoRequest) (*GetVersionInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersionInfo not implemented")
}
func (UnimplementedManagerServiceServer) ListProtocolOutputDirFiles(*ListProtocolOutputDirFilesRequest, ManagerService_ListProtocolOutputDirFilesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListProtocolOutputDirFiles not implemented")
}
func (UnimplementedManagerServiceServer) CreateDirectory(context.Context, *CreateDirectoryRequest) (*CreateDirectoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDirectory not implemented")
}
func (UnimplementedManagerServiceServer) GetDiskSpaceInfo(context.Context, *GetDiskSpaceInfoRequest) (*GetDiskSpaceInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDiskSpaceInfo not implemented")
}
func (UnimplementedManagerServiceServer) GetDefaultOutputDirectories(context.Context, *GetDefaultOutputDirectoriesRequest) (*OutputDirectories, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDefaultOutputDirectories not implemented")
}
func (UnimplementedManagerServiceServer) StreamDiskSpaceInfo(*StreamDiskSpaceInfoRequest, ManagerService_StreamDiskSpaceInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamDiskSpaceInfo not implemented")
}
func (UnimplementedManagerServiceServer) GetBarcodeKitInfo(context.Context, *GetBarcodeKitInfoRequest) (*GetBarcodeKitInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBarcodeKitInfo not implemented")
}
func (UnimplementedManagerServiceServer) GetLampKitInfo(context.Context, *GetLampKitInfoRequest) (*GetLampKitInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLampKitInfo not implemented")
}
func (UnimplementedManagerServiceServer) GetBarcodeKeys(context.Context, *GetBarcodeKeysRequest) (*GetBarcodeKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBarcodeKeys not implemented")
}
func (UnimplementedManagerServiceServer) GetFlowCellTypes(context.Context, *GetFlowCellTypesRequest) (*GetFlowCellTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFlowCellTypes not implemented")
}
func (UnimplementedManagerServiceServer) GetSequencingKits(context.Context, *GetSequencingKitsRequest) (*GetSequencingKitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSequencingKits not implemented")
}
func (UnimplementedManagerServiceServer) AddSimulatedDevice(context.Context, *AddSimulatedDeviceRequest) (*AddSimulatedDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSimulatedDevice not implemented")
}
func (UnimplementedManagerServiceServer) RemoveSimulatedDevice(context.Context, *RemoveSimulatedDeviceRequest) (*RemoveSimulatedDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveSimulatedDevice not implemented")
}
func (UnimplementedManagerServiceServer) LocalAuthenticationTokenPath(context.Context, *LocalAuthenticationTokenPathRequest) (*LocalAuthenticationTokenPathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LocalAuthenticationTokenPath not implemented")
}
func (UnimplementedManagerServiceServer) mustEmbedUnimplementedManagerServiceServer() {}

// UnsafeManagerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ManagerServiceServer will
// result in compilation errors.
type UnsafeManagerServiceServer interface {
	mustEmbedUnimplementedManagerServiceServer()
}

func RegisterManagerServiceServer(s grpc.ServiceRegistrar, srv ManagerServiceServer) {
	s.RegisterService(&ManagerService_ServiceDesc, srv)
}

func _ManagerService_DescribeHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).DescribeHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/describe_host",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).DescribeHost(ctx, req.(*DescribeHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_FlowCellPositions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FlowCellPositionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ManagerServiceServer).FlowCellPositions(m, &managerServiceFlowCellPositionsServer{stream})
}

type ManagerService_FlowCellPositionsServer interface {
	Send(*FlowCellPositionsResponse) error
	grpc.ServerStream
}

type managerServiceFlowCellPositionsServer struct {
	grpc.ServerStream
}

func (x *managerServiceFlowCellPositionsServer) Send(m *FlowCellPositionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ManagerService_WatchFlowCellPositions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchFlowCellPositionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ManagerServiceServer).WatchFlowCellPositions(m, &managerServiceWatchFlowCellPositionsServer{stream})
}

type ManagerService_WatchFlowCellPositionsServer interface {
	Send(*WatchFlowCellPositionsResponse) error
	grpc.ServerStream
}

type managerServiceWatchFlowCellPositionsServer struct {
	grpc.ServerStream
}

func (x *managerServiceWatchFlowCellPositionsServer) Send(m *WatchFlowCellPositionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ManagerService_ResetPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPositionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).ResetPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/reset_position",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).ResetPosition(ctx, req.(*ResetPositionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_BasecallerApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BasecallerApiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).BasecallerApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/basecaller_api",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).BasecallerApi(ctx, req.(*BasecallerApiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_GetGuppyInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGuppyInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).GetGuppyInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/get_guppy_info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).GetGuppyInfo(ctx, req.(*GetGuppyInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_GetVersionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).GetVersionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/get_version_info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).GetVersionInfo(ctx, req.(*GetVersionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_ListProtocolOutputDirFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListProtocolOutputDirFilesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ManagerServiceServer).ListProtocolOutputDirFiles(m, &managerServiceListProtocolOutputDirFilesServer{stream})
}

type ManagerService_ListProtocolOutputDirFilesServer interface {
	Send(*ListProtocolOutputDirFilesResponse) error
	grpc.ServerStream
}

type managerServiceListProtocolOutputDirFilesServer struct {
	grpc.ServerStream
}

func (x *managerServiceListProtocolOutputDirFilesServer) Send(m *ListProtocolOutputDirFilesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ManagerService_CreateDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDirectoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).CreateDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/create_directory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).CreateDirectory(ctx, req.(*CreateDirectoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_GetDiskSpaceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDiskSpaceInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).GetDiskSpaceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/get_disk_space_info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).GetDiskSpaceInfo(ctx, req.(*GetDiskSpaceInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_GetDefaultOutputDirectories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDefaultOutputDirectoriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).GetDefaultOutputDirectories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/get_default_output_directories",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).GetDefaultOutputDirectories(ctx, req.(*GetDefaultOutputDirectoriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_StreamDiskSpaceInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamDiskSpaceInfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ManagerServiceServer).StreamDiskSpaceInfo(m, &managerServiceStreamDiskSpaceInfoServer{stream})
}

type ManagerService_StreamDiskSpaceInfoServer interface {
	Send(*GetDiskSpaceInfoResponse) error
	grpc.ServerStream
}

type managerServiceStreamDiskSpaceInfoServer struct {
	grpc.ServerStream
}

func (x *managerServiceStreamDiskSpaceInfoServer) Send(m *GetDiskSpaceInfoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ManagerService_GetBarcodeKitInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBarcodeKitInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).GetBarcodeKitInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/get_barcode_kit_info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).GetBarcodeKitInfo(ctx, req.(*GetBarcodeKitInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_GetLampKitInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLampKitInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).GetLampKitInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/get_lamp_kit_info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).GetLampKitInfo(ctx, req.(*GetLampKitInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_GetBarcodeKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBarcodeKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).GetBarcodeKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/get_barcode_keys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).GetBarcodeKeys(ctx, req.(*GetBarcodeKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_GetFlowCellTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFlowCellTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).GetFlowCellTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/get_flow_cell_types",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).GetFlowCellTypes(ctx, req.(*GetFlowCellTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_GetSequencingKits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSequencingKitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).GetSequencingKits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/get_sequencing_kits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).GetSequencingKits(ctx, req.(*GetSequencingKitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_AddSimulatedDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSimulatedDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).AddSimulatedDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/add_simulated_device",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).AddSimulatedDevice(ctx, req.(*AddSimulatedDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_RemoveSimulatedDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveSimulatedDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).RemoveSimulatedDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/remove_simulated_device",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).RemoveSimulatedDevice(ctx, req.(*RemoveSimulatedDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerService_LocalAuthenticationTokenPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocalAuthenticationTokenPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServiceServer).LocalAuthenticationTokenPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.manager.ManagerService/local_authentication_token_path",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServiceServer).LocalAuthenticationTokenPath(ctx, req.(*LocalAuthenticationTokenPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ManagerService_ServiceDesc is the grpc.ServiceDesc for ManagerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ManagerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "minknow_api.manager.ManagerService",
	HandlerType: (*ManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "describe_host",
			Handler:    _ManagerService_DescribeHost_Handler,
		},
		{
			MethodName: "reset_position",
			Handler:    _ManagerService_ResetPosition_Handler,
		},
		{
			MethodName: "basecaller_api",
			Handler:    _ManagerService_BasecallerApi_Handler,
		},
		{
			MethodName: "get_guppy_info",
			Handler:    _ManagerService_GetGuppyInfo_Handler,
		},
		{
			MethodName: "get_version_info",
			Handler:    _ManagerService_GetVersionInfo_Handler,
		},
		{
			MethodName: "create_directory",
			Handler:    _ManagerService_CreateDirectory_Handler,
		},
		{
			MethodName: "get_disk_space_info",
			Handler:    _ManagerService_GetDiskSpaceInfo_Handler,
		},
		{
			MethodName: "get_default_output_directories",
			Handler:    _ManagerService_GetDefaultOutputDirectories_Handler,
		},
		{
			MethodName: "get_barcode_kit_info",
			Handler:    _ManagerService_GetBarcodeKitInfo_Handler,
		},
		{
			MethodName: "get_lamp_kit_info",
			Handler:    _ManagerService_GetLampKitInfo_Handler,
		},
		{
			MethodName: "get_barcode_keys",
			Handler:    _ManagerService_GetBarcodeKeys_Handler,
		},
		{
			MethodName: "get_flow_cell_types",
			Handler:    _ManagerService_GetFlowCellTypes_Handler,
		},
		{
			MethodName: "get_sequencing_kits",
			Handler:    _ManagerService_GetSequencingKits_Handler,
		},
		{
			MethodName: "add_simulated_device",
			Handler:    _ManagerService_AddSimulatedDevice_Handler,
		},
		{
			MethodName: "remove_simulated_device",
			Handler:    _ManagerService_RemoveSimulatedDevice_Handler,
		},
		{
			MethodName: "local_authentication_token_path",
			Handler:    _ManagerService_LocalAuthenticationTokenPath_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "flow_cell_positions",
			Handler:       _ManagerService_FlowCellPositions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "watch_flow_cell_positions",
			Handler:       _ManagerService_WatchFlowCellPositions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "list_protocol_output_dir_files",
			Handler:       _ManagerService_ListProtocolOutputDirFiles_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "stream_disk_space_info",
			Handler:       _ManagerService_StreamDiskSpaceInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "minknow_api/manager.proto",
}
