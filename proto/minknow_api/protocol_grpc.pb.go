// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package minknow

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ProtocolServiceClient is the client API for ProtocolService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProtocolServiceClient interface {
	// Initiates a python instance that runs the script specified by the `path` argument.
	// `list_protocols` will give back a list of protocol scripts that can be started by this call
	StartProtocol(ctx context.Context, in *StartProtocolRequest, opts ...grpc.CallOption) (*StartProtocolResponse, error)
	// Stops the currently running protocol script instance.
	StopProtocol(ctx context.Context, in *StopProtocolRequest, opts ...grpc.CallOption) (*StopProtocolResponse, error)
	// Wait for a protocol run to finish.
	//
	// The call blocks until the run with the given run ID has finished (or returns immediately if
	// it had already finished) and returns information about the protocol run.
	//
	// If no run has been started with the provided run ID (or no run ID is given), an error is
	// returned.
	//
	// If NOTIFY_BEFORE_TERMINATION is specified for state, the protocol end time is an estimate, including
	// the allowed timeout.
	//
	// Since 1.10
	WaitForFinished(ctx context.Context, in *WaitForFinishedRequest, opts ...grpc.CallOption) (*ProtocolRunInfo, error)
	// Gets information about a protocol run.
	//
	// If no run ID is provided, information about the most recently started protocol run is
	// provided.
	//
	// Since 1.10
	GetRunInfo(ctx context.Context, in *GetRunInfoRequest, opts ...grpc.CallOption) (*ProtocolRunInfo, error)
	// List previously started protocol run ids (including any current protocol), in order of starting.
	//
	// The returned object can be used to find protocol information with get_run_info.
	//
	// Since 1.11
	ListProtocolRuns(ctx context.Context, in *ListProtocolRunsRequest, opts ...grpc.CallOption) (*ListProtocolRunsResponse, error)
	// Returns the name and run id of the currently running protocol.
	//
	// Will fail with FAILED_PRECONDITION if there is no protocol running
	//
	// Since 1.11
	GetCurrentProtocolRun(ctx context.Context, in *GetCurrentProtocolRunRequest, opts ...grpc.CallOption) (*ProtocolRunInfo, error)
	// Returns current protocol run info and streams any changes to the current protocol
	//
	// This call can be made even if there is no current protocol running. In this case, the next streamed
	// response will be the start of a new protocol instance and you will receive updates for that protocol
	// until it finishes
	//
	// If a protocol finishes this stream will still continue to run and you will be notified when a new protocol starts
	//
	// Since 1.12
	WatchCurrentProtocolRun(ctx context.Context, in *WatchCurrentProtocolRunRequest, opts ...grpc.CallOption) (ProtocolService_WatchCurrentProtocolRunClient, error)
	// Gives back a list that contains info about each possible protocol script minknow is aware of.
	// This will most likely be used to retrieve a suitable protocol script that can be passed on to `start_protocol`
	//
	// Since 1.10
	ListProtocols(ctx context.Context, in *ListProtocolsRequest, opts ...grpc.CallOption) (*ListProtocolsResponse, error)
	// Returns string-to-string map of the context tags
	//
	// Since 1.11
	GetContextInfo(ctx context.Context, in *GetContextInfoRequest, opts ...grpc.CallOption) (*GetContextInfoResponse, error)
	// Store context tags as arbitary string-to-string map
	//
	// Since 1.11
	SetContextInfo(ctx context.Context, in *SetContextInfoRequest, opts ...grpc.CallOption) (*SetContextInfoResponse, error)
	// Value set by protocol scripts to define the purpose of the script. Gets this value
	//
	// Since 1.11
	GetProtocolPurpose(ctx context.Context, in *GetProtocolPurposeRequest, opts ...grpc.CallOption) (*GetProtocolPurposeResponse, error)
	// Sets the protocol purpose. See also get_protocol_purpose
	//
	// Since 1.11
	SetProtocolPurpose(ctx context.Context, in *SetProtocolPurposeRequest, opts ...grpc.CallOption) (*SetProtocolPurposeResponse, error)
	// Links an epi2me workflow reference to a run id.
	//
	// Since 1.15
	AddEpi2MeWorkflow(ctx context.Context, in *AddEpi2MeWorkflowRequest, opts ...grpc.CallOption) (*AddEpi2MeWorkflowResponse, error)
	// List all used protocol group ids used in any previous protocol on the box.
	//
	// Since 3.2
	ListProtocolGroupIds(ctx context.Context, in *ListProtocolGroupIdsRequest, opts ...grpc.CallOption) (*ListProtocolGroupIdsResponse, error)
	// Run a hardware check on the connected flow cell.
	//
	// Throws an error if there is no flow cell connected.
	//
	// Since 4.3
	BeginHardwareCheck(ctx context.Context, in *BeginHardwareCheckRequest, opts ...grpc.CallOption) (*BeginHardwareCheckResponse, error)
	// Run platform qc on the connected flow cell
	//
	// Throws an error if there is no flow cell connected.
	//
	// Since 4.3
	BeginPlatformQc(ctx context.Context, in *BeginPlatformQcRequest, opts ...grpc.CallOption) (*BeginPlatformQcResponse, error)
	// Given a protocol and some information about the flow-cell and kits will provide a list
	// of settings required by the protocol, their defaults and dependencies.
	//
	// Since 4.3
	ListSettingsForProtocol(ctx context.Context, in *ListSettingsForProtocolRequest, opts ...grpc.CallOption) (*ListSettingsForProtocolResponse, error)
}

type protocolServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProtocolServiceClient(cc grpc.ClientConnInterface) ProtocolServiceClient {
	return &protocolServiceClient{cc}
}

func (c *protocolServiceClient) StartProtocol(ctx context.Context, in *StartProtocolRequest, opts ...grpc.CallOption) (*StartProtocolResponse, error) {
	out := new(StartProtocolResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/start_protocol", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) StopProtocol(ctx context.Context, in *StopProtocolRequest, opts ...grpc.CallOption) (*StopProtocolResponse, error) {
	out := new(StopProtocolResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/stop_protocol", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) WaitForFinished(ctx context.Context, in *WaitForFinishedRequest, opts ...grpc.CallOption) (*ProtocolRunInfo, error) {
	out := new(ProtocolRunInfo)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/wait_for_finished", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) GetRunInfo(ctx context.Context, in *GetRunInfoRequest, opts ...grpc.CallOption) (*ProtocolRunInfo, error) {
	out := new(ProtocolRunInfo)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/get_run_info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) ListProtocolRuns(ctx context.Context, in *ListProtocolRunsRequest, opts ...grpc.CallOption) (*ListProtocolRunsResponse, error) {
	out := new(ListProtocolRunsResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/list_protocol_runs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) GetCurrentProtocolRun(ctx context.Context, in *GetCurrentProtocolRunRequest, opts ...grpc.CallOption) (*ProtocolRunInfo, error) {
	out := new(ProtocolRunInfo)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/get_current_protocol_run", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) WatchCurrentProtocolRun(ctx context.Context, in *WatchCurrentProtocolRunRequest, opts ...grpc.CallOption) (ProtocolService_WatchCurrentProtocolRunClient, error) {
	stream, err := c.cc.NewStream(ctx, &ProtocolService_ServiceDesc.Streams[0], "/minknow_api.protocol.ProtocolService/watch_current_protocol_run", opts...)
	if err != nil {
		return nil, err
	}
	x := &protocolServiceWatchCurrentProtocolRunClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ProtocolService_WatchCurrentProtocolRunClient interface {
	Recv() (*ProtocolRunInfo, error)
	grpc.ClientStream
}

type protocolServiceWatchCurrentProtocolRunClient struct {
	grpc.ClientStream
}

func (x *protocolServiceWatchCurrentProtocolRunClient) Recv() (*ProtocolRunInfo, error) {
	m := new(ProtocolRunInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *protocolServiceClient) ListProtocols(ctx context.Context, in *ListProtocolsRequest, opts ...grpc.CallOption) (*ListProtocolsResponse, error) {
	out := new(ListProtocolsResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/list_protocols", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) GetContextInfo(ctx context.Context, in *GetContextInfoRequest, opts ...grpc.CallOption) (*GetContextInfoResponse, error) {
	out := new(GetContextInfoResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/get_context_info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) SetContextInfo(ctx context.Context, in *SetContextInfoRequest, opts ...grpc.CallOption) (*SetContextInfoResponse, error) {
	out := new(SetContextInfoResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/set_context_info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) GetProtocolPurpose(ctx context.Context, in *GetProtocolPurposeRequest, opts ...grpc.CallOption) (*GetProtocolPurposeResponse, error) {
	out := new(GetProtocolPurposeResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/get_protocol_purpose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) SetProtocolPurpose(ctx context.Context, in *SetProtocolPurposeRequest, opts ...grpc.CallOption) (*SetProtocolPurposeResponse, error) {
	out := new(SetProtocolPurposeResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/set_protocol_purpose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) AddEpi2MeWorkflow(ctx context.Context, in *AddEpi2MeWorkflowRequest, opts ...grpc.CallOption) (*AddEpi2MeWorkflowResponse, error) {
	out := new(AddEpi2MeWorkflowResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/add_epi2me_workflow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) ListProtocolGroupIds(ctx context.Context, in *ListProtocolGroupIdsRequest, opts ...grpc.CallOption) (*ListProtocolGroupIdsResponse, error) {
	out := new(ListProtocolGroupIdsResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/list_protocol_group_ids", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) BeginHardwareCheck(ctx context.Context, in *BeginHardwareCheckRequest, opts ...grpc.CallOption) (*BeginHardwareCheckResponse, error) {
	out := new(BeginHardwareCheckResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/begin_hardware_check", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) BeginPlatformQc(ctx context.Context, in *BeginPlatformQcRequest, opts ...grpc.CallOption) (*BeginPlatformQcResponse, error) {
	out := new(BeginPlatformQcResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/begin_platform_qc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protocolServiceClient) ListSettingsForProtocol(ctx context.Context, in *ListSettingsForProtocolRequest, opts ...grpc.CallOption) (*ListSettingsForProtocolResponse, error) {
	out := new(ListSettingsForProtocolResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.protocol.ProtocolService/list_settings_for_protocol", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProtocolServiceServer is the server API for ProtocolService service.
// All implementations must embed UnimplementedProtocolServiceServer
// for forward compatibility
type ProtocolServiceServer interface {
	// Initiates a python instance that runs the script specified by the `path` argument.
	// `list_protocols` will give back a list of protocol scripts that can be started by this call
	StartProtocol(context.Context, *StartProtocolRequest) (*StartProtocolResponse, error)
	// Stops the currently running protocol script instance.
	StopProtocol(context.Context, *StopProtocolRequest) (*StopProtocolResponse, error)
	// Wait for a protocol run to finish.
	//
	// The call blocks until the run with the given run ID has finished (or returns immediately if
	// it had already finished) and returns information about the protocol run.
	//
	// If no run has been started with the provided run ID (or no run ID is given), an error is
	// returned.
	//
	// If NOTIFY_BEFORE_TERMINATION is specified for state, the protocol end time is an estimate, including
	// the allowed timeout.
	//
	// Since 1.10
	WaitForFinished(context.Context, *WaitForFinishedRequest) (*ProtocolRunInfo, error)
	// Gets information about a protocol run.
	//
	// If no run ID is provided, information about the most recently started protocol run is
	// provided.
	//
	// Since 1.10
	GetRunInfo(context.Context, *GetRunInfoRequest) (*ProtocolRunInfo, error)
	// List previously started protocol run ids (including any current protocol), in order of starting.
	//
	// The returned object can be used to find protocol information with get_run_info.
	//
	// Since 1.11
	ListProtocolRuns(context.Context, *ListProtocolRunsRequest) (*ListProtocolRunsResponse, error)
	// Returns the name and run id of the currently running protocol.
	//
	// Will fail with FAILED_PRECONDITION if there is no protocol running
	//
	// Since 1.11
	GetCurrentProtocolRun(context.Context, *GetCurrentProtocolRunRequest) (*ProtocolRunInfo, error)
	// Returns current protocol run info and streams any changes to the current protocol
	//
	// This call can be made even if there is no current protocol running. In this case, the next streamed
	// response will be the start of a new protocol instance and you will receive updates for that protocol
	// until it finishes
	//
	// If a protocol finishes this stream will still continue to run and you will be notified when a new protocol starts
	//
	// Since 1.12
	WatchCurrentProtocolRun(*WatchCurrentProtocolRunRequest, ProtocolService_WatchCurrentProtocolRunServer) error
	// Gives back a list that contains info about each possible protocol script minknow is aware of.
	// This will most likely be used to retrieve a suitable protocol script that can be passed on to `start_protocol`
	//
	// Since 1.10
	ListProtocols(context.Context, *ListProtocolsRequest) (*ListProtocolsResponse, error)
	// Returns string-to-string map of the context tags
	//
	// Since 1.11
	GetContextInfo(context.Context, *GetContextInfoRequest) (*GetContextInfoResponse, error)
	// Store context tags as arbitary string-to-string map
	//
	// Since 1.11
	SetContextInfo(context.Context, *SetContextInfoRequest) (*SetContextInfoResponse, error)
	// Value set by protocol scripts to define the purpose of the script. Gets this value
	//
	// Since 1.11
	GetProtocolPurpose(context.Context, *GetProtocolPurposeRequest) (*GetProtocolPurposeResponse, error)
	// Sets the protocol purpose. See also get_protocol_purpose
	//
	// Since 1.11
	SetProtocolPurpose(context.Context, *SetProtocolPurposeRequest) (*SetProtocolPurposeResponse, error)
	// Links an epi2me workflow reference to a run id.
	//
	// Since 1.15
	AddEpi2MeWorkflow(context.Context, *AddEpi2MeWorkflowRequest) (*AddEpi2MeWorkflowResponse, error)
	// List all used protocol group ids used in any previous protocol on the box.
	//
	// Since 3.2
	ListProtocolGroupIds(context.Context, *ListProtocolGroupIdsRequest) (*ListProtocolGroupIdsResponse, error)
	// Run a hardware check on the connected flow cell.
	//
	// Throws an error if there is no flow cell connected.
	//
	// Since 4.3
	BeginHardwareCheck(context.Context, *BeginHardwareCheckRequest) (*BeginHardwareCheckResponse, error)
	// Run platform qc on the connected flow cell
	//
	// Throws an error if there is no flow cell connected.
	//
	// Since 4.3
	BeginPlatformQc(context.Context, *BeginPlatformQcRequest) (*BeginPlatformQcResponse, error)
	// Given a protocol and some information about the flow-cell and kits will provide a list
	// of settings required by the protocol, their defaults and dependencies.
	//
	// Since 4.3
	ListSettingsForProtocol(context.Context, *ListSettingsForProtocolRequest) (*ListSettingsForProtocolResponse, error)
	mustEmbedUnimplementedProtocolServiceServer()
}

// UnimplementedProtocolServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProtocolServiceServer struct {
}

func (UnimplementedProtocolServiceServer) StartProtocol(context.Context, *StartProtocolRequest) (*StartProtocolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartProtocol not implemented")
}
func (UnimplementedProtocolServiceServer) StopProtocol(context.Context, *StopProtocolRequest) (*StopProtocolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopProtocol not implemented")
}
func (UnimplementedProtocolServiceServer) WaitForFinished(context.Context, *WaitForFinishedRequest) (*ProtocolRunInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForFinished not implemented")
}
func (UnimplementedProtocolServiceServer) GetRunInfo(context.Context, *GetRunInfoRequest) (*ProtocolRunInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRunInfo not implemented")
}
func (UnimplementedProtocolServiceServer) ListProtocolRuns(context.Context, *ListProtocolRunsRequest) (*ListProtocolRunsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProtocolRuns not implemented")
}
func (UnimplementedProtocolServiceServer) GetCurrentProtocolRun(context.Context, *GetCurrentProtocolRunRequest) (*ProtocolRunInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentProtocolRun not implemented")
}
func (UnimplementedProtocolServiceServer) WatchCurrentProtocolRun(*WatchCurrentProtocolRunRequest, ProtocolService_WatchCurrentProtocolRunServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchCurrentProtocolRun not implemented")
}
func (UnimplementedProtocolServiceServer) ListProtocols(context.Context, *ListProtocolsRequest) (*ListProtocolsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProtocols not implemented")
}
func (UnimplementedProtocolServiceServer) GetContextInfo(context.Context, *GetContextInfoRequest) (*GetContextInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetContextInfo not implemented")
}
func (UnimplementedProtocolServiceServer) SetContextInfo(context.Context, *SetContextInfoRequest) (*SetContextInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetContextInfo not implemented")
}
func (UnimplementedProtocolServiceServer) GetProtocolPurpose(context.Context, *GetProtocolPurposeRequest) (*GetProtocolPurposeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProtocolPurpose not implemented")
}
func (UnimplementedProtocolServiceServer) SetProtocolPurpose(context.Context, *SetProtocolPurposeRequest) (*SetProtocolPurposeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProtocolPurpose not implemented")
}
func (UnimplementedProtocolServiceServer) AddEpi2MeWorkflow(context.Context, *AddEpi2MeWorkflowRequest) (*AddEpi2MeWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddEpi2MeWorkflow not implemented")
}
func (UnimplementedProtocolServiceServer) ListProtocolGroupIds(context.Context, *ListProtocolGroupIdsRequest) (*ListProtocolGroupIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProtocolGroupIds not implemented")
}
func (UnimplementedProtocolServiceServer) BeginHardwareCheck(context.Context, *BeginHardwareCheckRequest) (*BeginHardwareCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BeginHardwareCheck not implemented")
}
func (UnimplementedProtocolServiceServer) BeginPlatformQc(context.Context, *BeginPlatformQcRequest) (*BeginPlatformQcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BeginPlatformQc not implemented")
}
func (UnimplementedProtocolServiceServer) ListSettingsForProtocol(context.Context, *ListSettingsForProtocolRequest) (*ListSettingsForProtocolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSettingsForProtocol not implemented")
}
func (UnimplementedProtocolServiceServer) mustEmbedUnimplementedProtocolServiceServer() {}

// UnsafeProtocolServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProtocolServiceServer will
// result in compilation errors.
type UnsafeProtocolServiceServer interface {
	mustEmbedUnimplementedProtocolServiceServer()
}

func RegisterProtocolServiceServer(s grpc.ServiceRegistrar, srv ProtocolServiceServer) {
	s.RegisterService(&ProtocolService_ServiceDesc, srv)
}

func _ProtocolService_StartProtocol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartProtocolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).StartProtocol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/start_protocol",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).StartProtocol(ctx, req.(*StartProtocolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_StopProtocol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopProtocolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).StopProtocol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/stop_protocol",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).StopProtocol(ctx, req.(*StopProtocolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_WaitForFinished_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitForFinishedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).WaitForFinished(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/wait_for_finished",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).WaitForFinished(ctx, req.(*WaitForFinishedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_GetRunInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).GetRunInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/get_run_info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).GetRunInfo(ctx, req.(*GetRunInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_ListProtocolRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProtocolRunsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).ListProtocolRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/list_protocol_runs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).ListProtocolRuns(ctx, req.(*ListProtocolRunsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_GetCurrentProtocolRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentProtocolRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).GetCurrentProtocolRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/get_current_protocol_run",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).GetCurrentProtocolRun(ctx, req.(*GetCurrentProtocolRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_WatchCurrentProtocolRun_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchCurrentProtocolRunRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ProtocolServiceServer).WatchCurrentProtocolRun(m, &protocolServiceWatchCurrentProtocolRunServer{stream})
}

type ProtocolService_WatchCurrentProtocolRunServer interface {
	Send(*ProtocolRunInfo) error
	grpc.ServerStream
}

type protocolServiceWatchCurrentProtocolRunServer struct {
	grpc.ServerStream
}

func (x *protocolServiceWatchCurrentProtocolRunServer) Send(m *ProtocolRunInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _ProtocolService_ListProtocols_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProtocolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).ListProtocols(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/list_protocols",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).ListProtocols(ctx, req.(*ListProtocolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_GetContextInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetContextInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).GetContextInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/get_context_info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).GetContextInfo(ctx, req.(*GetContextInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_SetContextInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetContextInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).SetContextInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/set_context_info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).SetContextInfo(ctx, req.(*SetContextInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_GetProtocolPurpose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProtocolPurposeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).GetProtocolPurpose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/get_protocol_purpose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).GetProtocolPurpose(ctx, req.(*GetProtocolPurposeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_SetProtocolPurpose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetProtocolPurposeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).SetProtocolPurpose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/set_protocol_purpose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).SetProtocolPurpose(ctx, req.(*SetProtocolPurposeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_AddEpi2MeWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddEpi2MeWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).AddEpi2MeWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/add_epi2me_workflow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).AddEpi2MeWorkflow(ctx, req.(*AddEpi2MeWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_ListProtocolGroupIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProtocolGroupIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).ListProtocolGroupIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/list_protocol_group_ids",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).ListProtocolGroupIds(ctx, req.(*ListProtocolGroupIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_BeginHardwareCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeginHardwareCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).BeginHardwareCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/begin_hardware_check",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).BeginHardwareCheck(ctx, req.(*BeginHardwareCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_BeginPlatformQc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeginPlatformQcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).BeginPlatformQc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/begin_platform_qc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).BeginPlatformQc(ctx, req.(*BeginPlatformQcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtocolService_ListSettingsForProtocol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSettingsForProtocolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtocolServiceServer).ListSettingsForProtocol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.protocol.ProtocolService/list_settings_for_protocol",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtocolServiceServer).ListSettingsForProtocol(ctx, req.(*ListSettingsForProtocolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProtocolService_ServiceDesc is the grpc.ServiceDesc for ProtocolService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProtocolService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "minknow_api.protocol.ProtocolService",
	HandlerType: (*ProtocolServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "start_protocol",
			Handler:    _ProtocolService_StartProtocol_Handler,
		},
		{
			MethodName: "stop_protocol",
			Handler:    _ProtocolService_StopProtocol_Handler,
		},
		{
			MethodName: "wait_for_finished",
			Handler:    _ProtocolService_WaitForFinished_Handler,
		},
		{
			MethodName: "get_run_info",
			Handler:    _ProtocolService_GetRunInfo_Handler,
		},
		{
			MethodName: "list_protocol_runs",
			Handler:    _ProtocolService_ListProtocolRuns_Handler,
		},
		{
			MethodName: "get_current_protocol_run",
			Handler:    _ProtocolService_GetCurrentProtocolRun_Handler,
		},
		{
			MethodName: "list_protocols",
			Handler:    _ProtocolService_ListProtocols_Handler,
		},
		{
			MethodName: "get_context_info",
			Handler:    _ProtocolService_GetContextInfo_Handler,
		},
		{
			MethodName: "set_context_info",
			Handler:    _ProtocolService_SetContextInfo_Handler,
		},
		{
			MethodName: "get_protocol_purpose",
			Handler:    _ProtocolService_GetProtocolPurpose_Handler,
		},
		{
			MethodName: "set_protocol_purpose",
			Handler:    _ProtocolService_SetProtocolPurpose_Handler,
		},
		{
			MethodName: "add_epi2me_workflow",
			Handler:    _ProtocolService_AddEpi2MeWorkflow_Handler,
		},
		{
			MethodName: "list_protocol_group_ids",
			Handler:    _ProtocolService_ListProtocolGroupIds_Handler,
		},
		{
			MethodName: "begin_hardware_check",
			Handler:    _ProtocolService_BeginHardwareCheck_Handler,
		},
		{
			MethodName: "begin_platform_qc",
			Handler:    _ProtocolService_BeginPlatformQc_Handler,
		},
		{
			MethodName: "list_settings_for_protocol",
			Handler:    _ProtocolService_ListSettingsForProtocol_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "watch_current_protocol_run",
			Handler:       _ProtocolService_WatchCurrentProtocolRun_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "minknow_api/protocol.proto",
}
