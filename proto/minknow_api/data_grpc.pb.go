// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package minknow

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// DataServiceClient is the client API for DataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataServiceClient interface {
	// Get the channel states for all channels from the device.
	//
	// This will return all the channel states from the moment of calling until the rpc is
	// closed by the user. If the user stops acquisition, the rpc will return with the
	// ABORTED status. If the user cancels the rpc, the status will be CANCELLED.
	//
	// The first messages returned will retrieve the current channel state for all channels
	// On the MinION, the current state for all channels will be included in the first message.
	// For PromethION, it will be split on multiple messages.
	//
	// To determine which channels have been returned, please check the channel member in the
	// messages returned in the response.
	//
	// The response will be streamed, and we will provide a message as soon as there are channel
	// state changes (though note that some channels could stay in the same state for a long time),
	// so there is no guaranteed frequency of the messages returned. However, because a response
	// message includes multiple channels, it is very likely that we have messages every few seconds.
	// As in, it is likely that at least some of the channels will change every so often, therefore
	// messages will be generated. For example, if 5 out of 512 channels change the state in the
	// same time, there will be a message containing all 5 changes. Later on, if other channels
	// change their state we will receive another message containing those and so on. Note that
	// MinKNOW tries to group as many channel state changes in a single message, up to the message
	// limit size, which is currently set to 32kB.
	GetChannelStates(ctx context.Context, in *GetChannelStatesRequest, opts ...grpc.CallOption) (DataService_GetChannelStatesClient, error)
	// Get the data types of data items produced by this service.
	//
	// In order to allow clients to efficiently deal with large volumes of data in languages such as
	// Python, this service can provide data as raw bytes. This call can be used to determine how to
	// interpret those bytes. This can be used to construct an appropriate numpy dtype, for example.
	GetDataTypes(ctx context.Context, in *GetDataTypesRequest, opts ...grpc.CallOption) (*GetDataTypesResponse, error)
	// Get signal data from the device.
	//
	// This can be used to sample the signal being produced by the device. The signal can be
	// returned as raw ADC values or as calibrated picoamp (pA) values; see ``set_calibration`` on
	// the device service for the values used in this conversion.
	//
	// In addition to the signal, this can return the associated channel configuration and/or bias
	// voltage information, to help analyse the data.
	//
	// If bias voltage information is requested, one bias voltage sample will be provided for each
	// signal sample (on any given channel). So if you request 20 samples of signal data and also
	// bias voltages, you will get 20 signal samples on each channel and also 20 bias voltage
	// samples. Bias voltages are always given in millivolts, and no corrections need to be applied
	// (for example, the 5x amplifier on a MinION is already accounted for).
	//
	// If channel configuration information is requested, each channel will have the starting
	// channel configuration (with offset 0 to indicate it applies to the first sample on that
	// channel), as well as any configuration changes that affect any of the returned samples.
	//
	// If a device settings change RPC has completed before this method is called, the data returned
	// is guaranteed to have been generated by the device after those settings were applied.
	// However, note that no guarantee is made about how device settings changes that overlap with
	// this request will affect the returned data.
	//
	// The response will be streamed. In order to limit the size of each response message, any given
	// message may include data from only a subset of the requested channels.
	//
	// Note that the data is returned as bytes fields. See the GetSignalBytesResponse documentation
	// for more details about how to interpret the value. In Python code, the minknow.Device class
	// provides a convenience wrapper method to convert the data into numpy arrays.
	GetSignalBytes(ctx context.Context, in *GetSignalBytesRequest, opts ...grpc.CallOption) (DataService_GetSignalBytesClient, error)
	// Get summarised signal data from the device.
	//
	// This provides signal data from the device, like get_signal_bytes, but instead of all the
	// data, it divides the data up into windows, and provides the minimum and maximum values for
	// each window.
	//
	// This call is aimed at visualisations of data (ie: a traceviewer interface). As such, it does
	// not provide most of the guarantees and options that get_signal_bytes() does. No bias voltage
	// or channel configuration data is provided, it is not possible to set the number of samples
	// desired up front (just cancel the call when no further data is required) and no guarantees
	// are made about whether particular commands have been applied to the returned data.
	//
	// Also unlike get_signal_bytes(), the returned data is in native types, and does not require
	// any further interpretation based on get_data_types(). This can be done performantly because
	// of the reduced amount of data transmitted.
	//
	// The response will be streamed. In order to limit the size of each response message, any given
	// message may include data from only a subset of the requested channels.
	GetSignalMinMax(ctx context.Context, in *GetSignalMinMaxRequest, opts ...grpc.CallOption) (DataService_GetSignalMinMaxClient, error)
	// Call this to force re-evaluating the channel states. This will make sure the next
	// channel state evaluated will be 'unclassified_following_reset'. If the analyser is behind,
	// and older data will come for evaluation, it will result in changing the state to 'pending_manual_reset'.
	// So tipically, after a resetting the channel states, the user would see in the bulk file
	// 'unclassified_following_reset', 'pending_manual_reset', 'pending_manual_reset', until the relevant data
	// comes through to the analyser and it will start outputting the normal channel states again.
	// If the analyser is not behind, the user should ideally see just the 'unclassified_following_reset' state.
	//
	// This call is blocking - it will return from the rpc when it would have processed the
	// 'unclassified_following_reset' in the analyser. If the rpc takes more than 1 minute
	// it will exit with the ABORTED status. This can happen if the analyser is more than 1 minute behind
	// for example (in practice it shouldn't be the case). If the RPC exits with the ABORT status, it means
	// the channels are to be reset in the future, but the analyser did not reach that point yet.
	//
	// Only one of these can be executed at a given time. If multiple threads call this simultaneously,
	// it will execute the first request and it will exit with FAILED_PRECONDITION for the rest. If an RPC
	// exited with the ABORT status, another RPC can immediately be started. The failed RPC would have not
	// reset the channel states, and the user could try again. The second RPC will return as soon as the first
	// reset happens, so this will not be necessarily waiting for the second acquisition index to be
	// processed.
	ResetChannelStates(ctx context.Context, in *ResetChannelStatesRequest, opts ...grpc.CallOption) (*ResetChannelStatesResponse, error)
	// Forces channels to be fixed on a custom channel state. The channels will not be re-evaluated until
	// they are activated using unlock_channel_states.
	// To create a channel state that will never be entered unless manually set using this call,
	// use the "never_evaluated" criteria:
	// "9": { "group": {...},
	//        "logic": {
	//            "rank": 0,
	//            "criteria": "never_evaluated"
	//             },
	//         "name": "custom_name_picked_by_the_user"
	//       }
	//
	// While the this RPC has the power of forcing a channel to any valid state other than 'unclassified',
	// it is intended to be used with channel states that are designed for this functionality (i.e. that
	// are never evaluated).
	// Has to be called while acquiring data, fails otherwise.
	// The forced channels are reset (reset = every channel back to being evaluated) every time a
	// new acquisition sequence is started.
	//
	// NOTE:
	// Calls to lock_channel_states and unlock_channel_states cannot be done in the same time.
	// If any of these two is called while any of these is already running, the grpc will return
	// with an error.
	LockChannelStates(ctx context.Context, in *LockChannelStatesRequest, opts ...grpc.CallOption) (*LockChannelStatesResponse, error)
	// Re-activates channels that have been turned-off with force_channels_to_state.
	// Note that 'turning off' refers to channel states only, everything else is still applied on the channel
	// (e.g. mux changes, saturation, commands etc)
	// No action is taken if the channel is already active.
	// Has to be called while acquiring data, fails otherwise.
	// NOTE:
	// Calls to lock_channel_states and unlock_channel_states cannot be done in the same time.
	// If any of these two is called while any of these is already running, the grpc will return
	// with an error.
	UnlockChannelStates(ctx context.Context, in *UnlockChannelStatesRequest, opts ...grpc.CallOption) (*UnlockChannelStatesResponse, error)
	// Get live reads sent in order to control sequencing behaviour.
	//
	// This method sends current reads (reads that are currently in the sequencer) to the user along
	// with live analysis data in order for real time decisions to be made.
	//
	// The method provides two streams:
	//
	// GetLiveReadsRequest stream:
	//      Sent by the user, provides MinKNOW with actions to take on current reads, actions
	//      taken are sumarised and sent back to the user in the GetLiveReadsResponse stream.
	// GetLiveReadsResponse stream:
	//      Sent to the user, contains a stream of ongoing sequencing information, sent as
	//      regularly as possible, with information on reads in progress, and feedback on actions
	//      taken on the data.
	//
	// note: This method operates on read chunks in MinKNOW, and will send at minimum, 1 read
	// chunk to the user. In order to reduce latency on the method, tune the following options:
	//
	// The raw chunk size data is processed in minknow (specified in samples):
	//      app_conf/hyperstream.raw_data_intermediate.size
	//      app_conf/hyperstream.raw_meta_data_intermediate.size
	//
	// The maximum read chunk size - changing the size read chunks are processed in minknow:
	//      analysis_conf/read_detection.break_reads_after_seconds
	//
	GetLiveReads(ctx context.Context, opts ...grpc.CallOption) (DataService_GetLiveReadsClient, error)
	// Collects statistics about read (chunk) lengths and signal, split by channel, channel
	// configuration and read (chunk) classification.
	GetReadStatistics(ctx context.Context, in *GetReadStatisticsRequest, opts ...grpc.CallOption) (*GetReadStatisticsResponse, error)
	// Returns various points of yield information for the ongoing experiment, such as complete
	// read information and basecaller progress.
	GetExperimentYieldInfo(ctx context.Context, in *GetExperimentYieldInfoRequest, opts ...grpc.CallOption) (*GetExperimentYieldInfoResponse, error)
}

type dataServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDataServiceClient(cc grpc.ClientConnInterface) DataServiceClient {
	return &dataServiceClient{cc}
}

func (c *dataServiceClient) GetChannelStates(ctx context.Context, in *GetChannelStatesRequest, opts ...grpc.CallOption) (DataService_GetChannelStatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[0], "/minknow_api.data.DataService/get_channel_states", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetChannelStatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetChannelStatesClient interface {
	Recv() (*GetChannelStatesResponse, error)
	grpc.ClientStream
}

type dataServiceGetChannelStatesClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetChannelStatesClient) Recv() (*GetChannelStatesResponse, error) {
	m := new(GetChannelStatesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetDataTypes(ctx context.Context, in *GetDataTypesRequest, opts ...grpc.CallOption) (*GetDataTypesResponse, error) {
	out := new(GetDataTypesResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.data.DataService/get_data_types", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetSignalBytes(ctx context.Context, in *GetSignalBytesRequest, opts ...grpc.CallOption) (DataService_GetSignalBytesClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[1], "/minknow_api.data.DataService/get_signal_bytes", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetSignalBytesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetSignalBytesClient interface {
	Recv() (*GetSignalBytesResponse, error)
	grpc.ClientStream
}

type dataServiceGetSignalBytesClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetSignalBytesClient) Recv() (*GetSignalBytesResponse, error) {
	m := new(GetSignalBytesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetSignalMinMax(ctx context.Context, in *GetSignalMinMaxRequest, opts ...grpc.CallOption) (DataService_GetSignalMinMaxClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[2], "/minknow_api.data.DataService/get_signal_min_max", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetSignalMinMaxClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetSignalMinMaxClient interface {
	Recv() (*GetSignalMinMaxResponse, error)
	grpc.ClientStream
}

type dataServiceGetSignalMinMaxClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetSignalMinMaxClient) Recv() (*GetSignalMinMaxResponse, error) {
	m := new(GetSignalMinMaxResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) ResetChannelStates(ctx context.Context, in *ResetChannelStatesRequest, opts ...grpc.CallOption) (*ResetChannelStatesResponse, error) {
	out := new(ResetChannelStatesResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.data.DataService/reset_channel_states", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) LockChannelStates(ctx context.Context, in *LockChannelStatesRequest, opts ...grpc.CallOption) (*LockChannelStatesResponse, error) {
	out := new(LockChannelStatesResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.data.DataService/lock_channel_states", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) UnlockChannelStates(ctx context.Context, in *UnlockChannelStatesRequest, opts ...grpc.CallOption) (*UnlockChannelStatesResponse, error) {
	out := new(UnlockChannelStatesResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.data.DataService/unlock_channel_states", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetLiveReads(ctx context.Context, opts ...grpc.CallOption) (DataService_GetLiveReadsClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[3], "/minknow_api.data.DataService/get_live_reads", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetLiveReadsClient{stream}
	return x, nil
}

type DataService_GetLiveReadsClient interface {
	Send(*GetLiveReadsRequest) error
	Recv() (*GetLiveReadsResponse, error)
	grpc.ClientStream
}

type dataServiceGetLiveReadsClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetLiveReadsClient) Send(m *GetLiveReadsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataServiceGetLiveReadsClient) Recv() (*GetLiveReadsResponse, error) {
	m := new(GetLiveReadsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetReadStatistics(ctx context.Context, in *GetReadStatisticsRequest, opts ...grpc.CallOption) (*GetReadStatisticsResponse, error) {
	out := new(GetReadStatisticsResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.data.DataService/get_read_statistics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetExperimentYieldInfo(ctx context.Context, in *GetExperimentYieldInfoRequest, opts ...grpc.CallOption) (*GetExperimentYieldInfoResponse, error) {
	out := new(GetExperimentYieldInfoResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.data.DataService/get_experiment_yield_info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataServiceServer is the server API for DataService service.
// All implementations must embed UnimplementedDataServiceServer
// for forward compatibility
type DataServiceServer interface {
	// Get the channel states for all channels from the device.
	//
	// This will return all the channel states from the moment of calling until the rpc is
	// closed by the user. If the user stops acquisition, the rpc will return with the
	// ABORTED status. If the user cancels the rpc, the status will be CANCELLED.
	//
	// The first messages returned will retrieve the current channel state for all channels
	// On the MinION, the current state for all channels will be included in the first message.
	// For PromethION, it will be split on multiple messages.
	//
	// To determine which channels have been returned, please check the channel member in the
	// messages returned in the response.
	//
	// The response will be streamed, and we will provide a message as soon as there are channel
	// state changes (though note that some channels could stay in the same state for a long time),
	// so there is no guaranteed frequency of the messages returned. However, because a response
	// message includes multiple channels, it is very likely that we have messages every few seconds.
	// As in, it is likely that at least some of the channels will change every so often, therefore
	// messages will be generated. For example, if 5 out of 512 channels change the state in the
	// same time, there will be a message containing all 5 changes. Later on, if other channels
	// change their state we will receive another message containing those and so on. Note that
	// MinKNOW tries to group as many channel state changes in a single message, up to the message
	// limit size, which is currently set to 32kB.
	GetChannelStates(*GetChannelStatesRequest, DataService_GetChannelStatesServer) error
	// Get the data types of data items produced by this service.
	//
	// In order to allow clients to efficiently deal with large volumes of data in languages such as
	// Python, this service can provide data as raw bytes. This call can be used to determine how to
	// interpret those bytes. This can be used to construct an appropriate numpy dtype, for example.
	GetDataTypes(context.Context, *GetDataTypesRequest) (*GetDataTypesResponse, error)
	// Get signal data from the device.
	//
	// This can be used to sample the signal being produced by the device. The signal can be
	// returned as raw ADC values or as calibrated picoamp (pA) values; see ``set_calibration`` on
	// the device service for the values used in this conversion.
	//
	// In addition to the signal, this can return the associated channel configuration and/or bias
	// voltage information, to help analyse the data.
	//
	// If bias voltage information is requested, one bias voltage sample will be provided for each
	// signal sample (on any given channel). So if you request 20 samples of signal data and also
	// bias voltages, you will get 20 signal samples on each channel and also 20 bias voltage
	// samples. Bias voltages are always given in millivolts, and no corrections need to be applied
	// (for example, the 5x amplifier on a MinION is already accounted for).
	//
	// If channel configuration information is requested, each channel will have the starting
	// channel configuration (with offset 0 to indicate it applies to the first sample on that
	// channel), as well as any configuration changes that affect any of the returned samples.
	//
	// If a device settings change RPC has completed before this method is called, the data returned
	// is guaranteed to have been generated by the device after those settings were applied.
	// However, note that no guarantee is made about how device settings changes that overlap with
	// this request will affect the returned data.
	//
	// The response will be streamed. In order to limit the size of each response message, any given
	// message may include data from only a subset of the requested channels.
	//
	// Note that the data is returned as bytes fields. See the GetSignalBytesResponse documentation
	// for more details about how to interpret the value. In Python code, the minknow.Device class
	// provides a convenience wrapper method to convert the data into numpy arrays.
	GetSignalBytes(*GetSignalBytesRequest, DataService_GetSignalBytesServer) error
	// Get summarised signal data from the device.
	//
	// This provides signal data from the device, like get_signal_bytes, but instead of all the
	// data, it divides the data up into windows, and provides the minimum and maximum values for
	// each window.
	//
	// This call is aimed at visualisations of data (ie: a traceviewer interface). As such, it does
	// not provide most of the guarantees and options that get_signal_bytes() does. No bias voltage
	// or channel configuration data is provided, it is not possible to set the number of samples
	// desired up front (just cancel the call when no further data is required) and no guarantees
	// are made about whether particular commands have been applied to the returned data.
	//
	// Also unlike get_signal_bytes(), the returned data is in native types, and does not require
	// any further interpretation based on get_data_types(). This can be done performantly because
	// of the reduced amount of data transmitted.
	//
	// The response will be streamed. In order to limit the size of each response message, any given
	// message may include data from only a subset of the requested channels.
	GetSignalMinMax(*GetSignalMinMaxRequest, DataService_GetSignalMinMaxServer) error
	// Call this to force re-evaluating the channel states. This will make sure the next
	// channel state evaluated will be 'unclassified_following_reset'. If the analyser is behind,
	// and older data will come for evaluation, it will result in changing the state to 'pending_manual_reset'.
	// So tipically, after a resetting the channel states, the user would see in the bulk file
	// 'unclassified_following_reset', 'pending_manual_reset', 'pending_manual_reset', until the relevant data
	// comes through to the analyser and it will start outputting the normal channel states again.
	// If the analyser is not behind, the user should ideally see just the 'unclassified_following_reset' state.
	//
	// This call is blocking - it will return from the rpc when it would have processed the
	// 'unclassified_following_reset' in the analyser. If the rpc takes more than 1 minute
	// it will exit with the ABORTED status. This can happen if the analyser is more than 1 minute behind
	// for example (in practice it shouldn't be the case). If the RPC exits with the ABORT status, it means
	// the channels are to be reset in the future, but the analyser did not reach that point yet.
	//
	// Only one of these can be executed at a given time. If multiple threads call this simultaneously,
	// it will execute the first request and it will exit with FAILED_PRECONDITION for the rest. If an RPC
	// exited with the ABORT status, another RPC can immediately be started. The failed RPC would have not
	// reset the channel states, and the user could try again. The second RPC will return as soon as the first
	// reset happens, so this will not be necessarily waiting for the second acquisition index to be
	// processed.
	ResetChannelStates(context.Context, *ResetChannelStatesRequest) (*ResetChannelStatesResponse, error)
	// Forces channels to be fixed on a custom channel state. The channels will not be re-evaluated until
	// they are activated using unlock_channel_states.
	// To create a channel state that will never be entered unless manually set using this call,
	// use the "never_evaluated" criteria:
	// "9": { "group": {...},
	//        "logic": {
	//            "rank": 0,
	//            "criteria": "never_evaluated"
	//             },
	//         "name": "custom_name_picked_by_the_user"
	//       }
	//
	// While the this RPC has the power of forcing a channel to any valid state other than 'unclassified',
	// it is intended to be used with channel states that are designed for this functionality (i.e. that
	// are never evaluated).
	// Has to be called while acquiring data, fails otherwise.
	// The forced channels are reset (reset = every channel back to being evaluated) every time a
	// new acquisition sequence is started.
	//
	// NOTE:
	// Calls to lock_channel_states and unlock_channel_states cannot be done in the same time.
	// If any of these two is called while any of these is already running, the grpc will return
	// with an error.
	LockChannelStates(context.Context, *LockChannelStatesRequest) (*LockChannelStatesResponse, error)
	// Re-activates channels that have been turned-off with force_channels_to_state.
	// Note that 'turning off' refers to channel states only, everything else is still applied on the channel
	// (e.g. mux changes, saturation, commands etc)
	// No action is taken if the channel is already active.
	// Has to be called while acquiring data, fails otherwise.
	// NOTE:
	// Calls to lock_channel_states and unlock_channel_states cannot be done in the same time.
	// If any of these two is called while any of these is already running, the grpc will return
	// with an error.
	UnlockChannelStates(context.Context, *UnlockChannelStatesRequest) (*UnlockChannelStatesResponse, error)
	// Get live reads sent in order to control sequencing behaviour.
	//
	// This method sends current reads (reads that are currently in the sequencer) to the user along
	// with live analysis data in order for real time decisions to be made.
	//
	// The method provides two streams:
	//
	// GetLiveReadsRequest stream:
	//      Sent by the user, provides MinKNOW with actions to take on current reads, actions
	//      taken are sumarised and sent back to the user in the GetLiveReadsResponse stream.
	// GetLiveReadsResponse stream:
	//      Sent to the user, contains a stream of ongoing sequencing information, sent as
	//      regularly as possible, with information on reads in progress, and feedback on actions
	//      taken on the data.
	//
	// note: This method operates on read chunks in MinKNOW, and will send at minimum, 1 read
	// chunk to the user. In order to reduce latency on the method, tune the following options:
	//
	// The raw chunk size data is processed in minknow (specified in samples):
	//      app_conf/hyperstream.raw_data_intermediate.size
	//      app_conf/hyperstream.raw_meta_data_intermediate.size
	//
	// The maximum read chunk size - changing the size read chunks are processed in minknow:
	//      analysis_conf/read_detection.break_reads_after_seconds
	//
	GetLiveReads(DataService_GetLiveReadsServer) error
	// Collects statistics about read (chunk) lengths and signal, split by channel, channel
	// configuration and read (chunk) classification.
	GetReadStatistics(context.Context, *GetReadStatisticsRequest) (*GetReadStatisticsResponse, error)
	// Returns various points of yield information for the ongoing experiment, such as complete
	// read information and basecaller progress.
	GetExperimentYieldInfo(context.Context, *GetExperimentYieldInfoRequest) (*GetExperimentYieldInfoResponse, error)
	mustEmbedUnimplementedDataServiceServer()
}

// UnimplementedDataServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDataServiceServer struct {
}

func (UnimplementedDataServiceServer) GetChannelStates(*GetChannelStatesRequest, DataService_GetChannelStatesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetChannelStates not implemented")
}
func (UnimplementedDataServiceServer) GetDataTypes(context.Context, *GetDataTypesRequest) (*GetDataTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDataTypes not implemented")
}
func (UnimplementedDataServiceServer) GetSignalBytes(*GetSignalBytesRequest, DataService_GetSignalBytesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSignalBytes not implemented")
}
func (UnimplementedDataServiceServer) GetSignalMinMax(*GetSignalMinMaxRequest, DataService_GetSignalMinMaxServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSignalMinMax not implemented")
}
func (UnimplementedDataServiceServer) ResetChannelStates(context.Context, *ResetChannelStatesRequest) (*ResetChannelStatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetChannelStates not implemented")
}
func (UnimplementedDataServiceServer) LockChannelStates(context.Context, *LockChannelStatesRequest) (*LockChannelStatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockChannelStates not implemented")
}
func (UnimplementedDataServiceServer) UnlockChannelStates(context.Context, *UnlockChannelStatesRequest) (*UnlockChannelStatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockChannelStates not implemented")
}
func (UnimplementedDataServiceServer) GetLiveReads(DataService_GetLiveReadsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetLiveReads not implemented")
}
func (UnimplementedDataServiceServer) GetReadStatistics(context.Context, *GetReadStatisticsRequest) (*GetReadStatisticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReadStatistics not implemented")
}
func (UnimplementedDataServiceServer) GetExperimentYieldInfo(context.Context, *GetExperimentYieldInfoRequest) (*GetExperimentYieldInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExperimentYieldInfo not implemented")
}
func (UnimplementedDataServiceServer) mustEmbedUnimplementedDataServiceServer() {}

// UnsafeDataServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataServiceServer will
// result in compilation errors.
type UnsafeDataServiceServer interface {
	mustEmbedUnimplementedDataServiceServer()
}

func RegisterDataServiceServer(s grpc.ServiceRegistrar, srv DataServiceServer) {
	s.RegisterService(&DataService_ServiceDesc, srv)
}

func _DataService_GetChannelStates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetChannelStatesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetChannelStates(m, &dataServiceGetChannelStatesServer{stream})
}

type DataService_GetChannelStatesServer interface {
	Send(*GetChannelStatesResponse) error
	grpc.ServerStream
}

type dataServiceGetChannelStatesServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetChannelStatesServer) Send(m *GetChannelStatesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetDataTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDataTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetDataTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.data.DataService/get_data_types",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetDataTypes(ctx, req.(*GetDataTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetSignalBytes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetSignalBytesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetSignalBytes(m, &dataServiceGetSignalBytesServer{stream})
}

type DataService_GetSignalBytesServer interface {
	Send(*GetSignalBytesResponse) error
	grpc.ServerStream
}

type dataServiceGetSignalBytesServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetSignalBytesServer) Send(m *GetSignalBytesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetSignalMinMax_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetSignalMinMaxRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetSignalMinMax(m, &dataServiceGetSignalMinMaxServer{stream})
}

type DataService_GetSignalMinMaxServer interface {
	Send(*GetSignalMinMaxResponse) error
	grpc.ServerStream
}

type dataServiceGetSignalMinMaxServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetSignalMinMaxServer) Send(m *GetSignalMinMaxResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_ResetChannelStates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetChannelStatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).ResetChannelStates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.data.DataService/reset_channel_states",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).ResetChannelStates(ctx, req.(*ResetChannelStatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_LockChannelStates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockChannelStatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).LockChannelStates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.data.DataService/lock_channel_states",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).LockChannelStates(ctx, req.(*LockChannelStatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_UnlockChannelStates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockChannelStatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).UnlockChannelStates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.data.DataService/unlock_channel_states",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).UnlockChannelStates(ctx, req.(*UnlockChannelStatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetLiveReads_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataServiceServer).GetLiveReads(&dataServiceGetLiveReadsServer{stream})
}

type DataService_GetLiveReadsServer interface {
	Send(*GetLiveReadsResponse) error
	Recv() (*GetLiveReadsRequest, error)
	grpc.ServerStream
}

type dataServiceGetLiveReadsServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetLiveReadsServer) Send(m *GetLiveReadsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataServiceGetLiveReadsServer) Recv() (*GetLiveReadsRequest, error) {
	m := new(GetLiveReadsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataService_GetReadStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReadStatisticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetReadStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.data.DataService/get_read_statistics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetReadStatistics(ctx, req.(*GetReadStatisticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetExperimentYieldInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExperimentYieldInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetExperimentYieldInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.data.DataService/get_experiment_yield_info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetExperimentYieldInfo(ctx, req.(*GetExperimentYieldInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DataService_ServiceDesc is the grpc.ServiceDesc for DataService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "minknow_api.data.DataService",
	HandlerType: (*DataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "get_data_types",
			Handler:    _DataService_GetDataTypes_Handler,
		},
		{
			MethodName: "reset_channel_states",
			Handler:    _DataService_ResetChannelStates_Handler,
		},
		{
			MethodName: "lock_channel_states",
			Handler:    _DataService_LockChannelStates_Handler,
		},
		{
			MethodName: "unlock_channel_states",
			Handler:    _DataService_UnlockChannelStates_Handler,
		},
		{
			MethodName: "get_read_statistics",
			Handler:    _DataService_GetReadStatistics_Handler,
		},
		{
			MethodName: "get_experiment_yield_info",
			Handler:    _DataService_GetExperimentYieldInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "get_channel_states",
			Handler:       _DataService_GetChannelStates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "get_signal_bytes",
			Handler:       _DataService_GetSignalBytes_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "get_signal_min_max",
			Handler:       _DataService_GetSignalMinMax_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "get_live_reads",
			Handler:       _DataService_GetLiveReads_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "minknow_api/data.proto",
}
