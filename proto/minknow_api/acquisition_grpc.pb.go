// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package minknow

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AcquisitionServiceClient is the client API for AcquisitionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AcquisitionServiceClient interface {
	// Starts reading data from the device
	//
	// Some setup calls will need to be made before starting data acquisition: particularly setting the analysis configuration,
	// calibration, read writer and bulk writer config and some device calls such as setting the sampling frequency
	//
	// If acqusition is already running (even in the FINISHING state), this call will fail.
	//
	// On MinIONs and GridIONs, this will enable the ASIC power supply if it is not already enabled.
	// See StopRequest.keep_power_on for more details about the implications of this.
	//
	// The rpc will return once `current_status` is "PROCESSING" or an error occurs and acqusition fails to start.
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error)
	// Stops data acquisition.
	//
	// Can specify a stop mode that handles what is done with the data when data acquisition is stopped. Refer to the enum
	// description for documentation on what each mode does.
	//
	// Be aware that this command will return as soon as Minknow enters the FINISHING state and not the READY state.
	// So if starting a new experiment then you will have to wait for the READY state seperately
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)
	// Watches for status changes within MinKNOW. Status states are defined from MinknowStatus enum.
	// This is a bi-directional stream where the incoming response stream will return everytime the status has changed
	// and the request stream is used to stop the watcher. Refer to http://www.grpc.io/docs/tutorials/basic/python.html
	// to see how bi-directoional streaming works in grpc, but essentially when calling this function the user will have
	// to pass in a generator that will eventually yield a WatchForStatusChangeRequest(stop=True) to the cpp side.
	// A wrapper class for this is provided in the Python code.
	//
	// The function will first return with the current status that MinKNOW is in. Every response thereafter will be a
	// change from one status to another.
	//
	// The ERROR_STATUS state includes errors during transition between states. If that happens, MinKNOW will
	// try to revert to the READY state. It is up to the user to determine if they wish to try to wait for MinKNOW to
	// correct itself or to try some other course of action
	WatchForStatusChange(ctx context.Context, opts ...grpc.CallOption) (AcquisitionService_WatchForStatusChangeClient, error)
	// Returns current acquisition run info and streams any changes to the current acquisition
	//
	// This call can be made even if acquisition is not running. In this case, the next streamed
	// response will be the start of a new acquisition and you will receive updates for that acquisition
	// until it finishes.
	//
	// If an acquisition finishes this stream will still continue to run and you will be notified when a new acquisition starts.
	//
	// Note if you begin this stream before any acquisition is started in minknow the state is `ACQUISITION_COMPLETED`.
	//
	// Since 1.13
	WatchCurrentAcquisitionRun(ctx context.Context, in *WatchCurrentAcquisitionRunRequest, opts ...grpc.CallOption) (AcquisitionService_WatchCurrentAcquisitionRunClient, error)
	// Check the current status of MinKNOW.
	CurrentStatus(ctx context.Context, in *CurrentStatusRequest, opts ...grpc.CallOption) (*CurrentStatusResponse, error)
	// Information on how much data has been acquired, processed and written.
	GetProgress(ctx context.Context, in *GetProgressRequest, opts ...grpc.CallOption) (*GetProgressResponse, error)
	// Gets information about an acquisition run, run within this instance on MinKNOW.
	//
	// If no run ID is provided, information about the most recently started acquisition run is
	// provided.
	//
	// Since 1.11
	GetAcquisitionInfo(ctx context.Context, in *GetAcquisitionRunInfoRequest, opts ...grpc.CallOption) (*AcquisitionRunInfo, error)
	// Gets information about all previous acquisitions.
	//
	// Since 1.11
	ListAcquisitionRuns(ctx context.Context, in *ListAcquisitionRunsRequest, opts ...grpc.CallOption) (*ListAcquisitionRunsResponse, error)
	// Returns the name and run id of the currently running acquisition.
	//
	// Will fail with FAILED_PRECONDITION if there is no acquisition running
	//
	// Since 1.11
	GetCurrentAcquisitionRun(ctx context.Context, in *GetCurrentAcquisitionRunRequest, opts ...grpc.CallOption) (*AcquisitionRunInfo, error)
	// Specify the signal reader to use
	//
	// Since 3.6
	SetSignalReader(ctx context.Context, in *SetSignalReaderRequest, opts ...grpc.CallOption) (*SetSignalReaderResponse, error)
}

type acquisitionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAcquisitionServiceClient(cc grpc.ClientConnInterface) AcquisitionServiceClient {
	return &acquisitionServiceClient{cc}
}

func (c *acquisitionServiceClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error) {
	out := new(StartResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.acquisition.AcquisitionService/start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *acquisitionServiceClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {
	out := new(StopResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.acquisition.AcquisitionService/stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *acquisitionServiceClient) WatchForStatusChange(ctx context.Context, opts ...grpc.CallOption) (AcquisitionService_WatchForStatusChangeClient, error) {
	stream, err := c.cc.NewStream(ctx, &AcquisitionService_ServiceDesc.Streams[0], "/minknow_api.acquisition.AcquisitionService/watch_for_status_change", opts...)
	if err != nil {
		return nil, err
	}
	x := &acquisitionServiceWatchForStatusChangeClient{stream}
	return x, nil
}

type AcquisitionService_WatchForStatusChangeClient interface {
	Send(*WatchForStatusChangeRequest) error
	Recv() (*WatchForStatusChangeResponse, error)
	grpc.ClientStream
}

type acquisitionServiceWatchForStatusChangeClient struct {
	grpc.ClientStream
}

func (x *acquisitionServiceWatchForStatusChangeClient) Send(m *WatchForStatusChangeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *acquisitionServiceWatchForStatusChangeClient) Recv() (*WatchForStatusChangeResponse, error) {
	m := new(WatchForStatusChangeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *acquisitionServiceClient) WatchCurrentAcquisitionRun(ctx context.Context, in *WatchCurrentAcquisitionRunRequest, opts ...grpc.CallOption) (AcquisitionService_WatchCurrentAcquisitionRunClient, error) {
	stream, err := c.cc.NewStream(ctx, &AcquisitionService_ServiceDesc.Streams[1], "/minknow_api.acquisition.AcquisitionService/watch_current_acquisition_run", opts...)
	if err != nil {
		return nil, err
	}
	x := &acquisitionServiceWatchCurrentAcquisitionRunClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AcquisitionService_WatchCurrentAcquisitionRunClient interface {
	Recv() (*AcquisitionRunInfo, error)
	grpc.ClientStream
}

type acquisitionServiceWatchCurrentAcquisitionRunClient struct {
	grpc.ClientStream
}

func (x *acquisitionServiceWatchCurrentAcquisitionRunClient) Recv() (*AcquisitionRunInfo, error) {
	m := new(AcquisitionRunInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *acquisitionServiceClient) CurrentStatus(ctx context.Context, in *CurrentStatusRequest, opts ...grpc.CallOption) (*CurrentStatusResponse, error) {
	out := new(CurrentStatusResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.acquisition.AcquisitionService/current_status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *acquisitionServiceClient) GetProgress(ctx context.Context, in *GetProgressRequest, opts ...grpc.CallOption) (*GetProgressResponse, error) {
	out := new(GetProgressResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.acquisition.AcquisitionService/get_progress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *acquisitionServiceClient) GetAcquisitionInfo(ctx context.Context, in *GetAcquisitionRunInfoRequest, opts ...grpc.CallOption) (*AcquisitionRunInfo, error) {
	out := new(AcquisitionRunInfo)
	err := c.cc.Invoke(ctx, "/minknow_api.acquisition.AcquisitionService/get_acquisition_info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *acquisitionServiceClient) ListAcquisitionRuns(ctx context.Context, in *ListAcquisitionRunsRequest, opts ...grpc.CallOption) (*ListAcquisitionRunsResponse, error) {
	out := new(ListAcquisitionRunsResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.acquisition.AcquisitionService/list_acquisition_runs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *acquisitionServiceClient) GetCurrentAcquisitionRun(ctx context.Context, in *GetCurrentAcquisitionRunRequest, opts ...grpc.CallOption) (*AcquisitionRunInfo, error) {
	out := new(AcquisitionRunInfo)
	err := c.cc.Invoke(ctx, "/minknow_api.acquisition.AcquisitionService/get_current_acquisition_run", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *acquisitionServiceClient) SetSignalReader(ctx context.Context, in *SetSignalReaderRequest, opts ...grpc.CallOption) (*SetSignalReaderResponse, error) {
	out := new(SetSignalReaderResponse)
	err := c.cc.Invoke(ctx, "/minknow_api.acquisition.AcquisitionService/set_signal_reader", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AcquisitionServiceServer is the server API for AcquisitionService service.
// All implementations must embed UnimplementedAcquisitionServiceServer
// for forward compatibility
type AcquisitionServiceServer interface {
	// Starts reading data from the device
	//
	// Some setup calls will need to be made before starting data acquisition: particularly setting the analysis configuration,
	// calibration, read writer and bulk writer config and some device calls such as setting the sampling frequency
	//
	// If acqusition is already running (even in the FINISHING state), this call will fail.
	//
	// On MinIONs and GridIONs, this will enable the ASIC power supply if it is not already enabled.
	// See StopRequest.keep_power_on for more details about the implications of this.
	//
	// The rpc will return once `current_status` is "PROCESSING" or an error occurs and acqusition fails to start.
	Start(context.Context, *StartRequest) (*StartResponse, error)
	// Stops data acquisition.
	//
	// Can specify a stop mode that handles what is done with the data when data acquisition is stopped. Refer to the enum
	// description for documentation on what each mode does.
	//
	// Be aware that this command will return as soon as Minknow enters the FINISHING state and not the READY state.
	// So if starting a new experiment then you will have to wait for the READY state seperately
	Stop(context.Context, *StopRequest) (*StopResponse, error)
	// Watches for status changes within MinKNOW. Status states are defined from MinknowStatus enum.
	// This is a bi-directional stream where the incoming response stream will return everytime the status has changed
	// and the request stream is used to stop the watcher. Refer to http://www.grpc.io/docs/tutorials/basic/python.html
	// to see how bi-directoional streaming works in grpc, but essentially when calling this function the user will have
	// to pass in a generator that will eventually yield a WatchForStatusChangeRequest(stop=True) to the cpp side.
	// A wrapper class for this is provided in the Python code.
	//
	// The function will first return with the current status that MinKNOW is in. Every response thereafter will be a
	// change from one status to another.
	//
	// The ERROR_STATUS state includes errors during transition between states. If that happens, MinKNOW will
	// try to revert to the READY state. It is up to the user to determine if they wish to try to wait for MinKNOW to
	// correct itself or to try some other course of action
	WatchForStatusChange(AcquisitionService_WatchForStatusChangeServer) error
	// Returns current acquisition run info and streams any changes to the current acquisition
	//
	// This call can be made even if acquisition is not running. In this case, the next streamed
	// response will be the start of a new acquisition and you will receive updates for that acquisition
	// until it finishes.
	//
	// If an acquisition finishes this stream will still continue to run and you will be notified when a new acquisition starts.
	//
	// Note if you begin this stream before any acquisition is started in minknow the state is `ACQUISITION_COMPLETED`.
	//
	// Since 1.13
	WatchCurrentAcquisitionRun(*WatchCurrentAcquisitionRunRequest, AcquisitionService_WatchCurrentAcquisitionRunServer) error
	// Check the current status of MinKNOW.
	CurrentStatus(context.Context, *CurrentStatusRequest) (*CurrentStatusResponse, error)
	// Information on how much data has been acquired, processed and written.
	GetProgress(context.Context, *GetProgressRequest) (*GetProgressResponse, error)
	// Gets information about an acquisition run, run within this instance on MinKNOW.
	//
	// If no run ID is provided, information about the most recently started acquisition run is
	// provided.
	//
	// Since 1.11
	GetAcquisitionInfo(context.Context, *GetAcquisitionRunInfoRequest) (*AcquisitionRunInfo, error)
	// Gets information about all previous acquisitions.
	//
	// Since 1.11
	ListAcquisitionRuns(context.Context, *ListAcquisitionRunsRequest) (*ListAcquisitionRunsResponse, error)
	// Returns the name and run id of the currently running acquisition.
	//
	// Will fail with FAILED_PRECONDITION if there is no acquisition running
	//
	// Since 1.11
	GetCurrentAcquisitionRun(context.Context, *GetCurrentAcquisitionRunRequest) (*AcquisitionRunInfo, error)
	// Specify the signal reader to use
	//
	// Since 3.6
	SetSignalReader(context.Context, *SetSignalReaderRequest) (*SetSignalReaderResponse, error)
	mustEmbedUnimplementedAcquisitionServiceServer()
}

// UnimplementedAcquisitionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAcquisitionServiceServer struct {
}

func (UnimplementedAcquisitionServiceServer) Start(context.Context, *StartRequest) (*StartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (UnimplementedAcquisitionServiceServer) Stop(context.Context, *StopRequest) (*StopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedAcquisitionServiceServer) WatchForStatusChange(AcquisitionService_WatchForStatusChangeServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchForStatusChange not implemented")
}
func (UnimplementedAcquisitionServiceServer) WatchCurrentAcquisitionRun(*WatchCurrentAcquisitionRunRequest, AcquisitionService_WatchCurrentAcquisitionRunServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchCurrentAcquisitionRun not implemented")
}
func (UnimplementedAcquisitionServiceServer) CurrentStatus(context.Context, *CurrentStatusRequest) (*CurrentStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentStatus not implemented")
}
func (UnimplementedAcquisitionServiceServer) GetProgress(context.Context, *GetProgressRequest) (*GetProgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgress not implemented")
}
func (UnimplementedAcquisitionServiceServer) GetAcquisitionInfo(context.Context, *GetAcquisitionRunInfoRequest) (*AcquisitionRunInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAcquisitionInfo not implemented")
}
func (UnimplementedAcquisitionServiceServer) ListAcquisitionRuns(context.Context, *ListAcquisitionRunsRequest) (*ListAcquisitionRunsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAcquisitionRuns not implemented")
}
func (UnimplementedAcquisitionServiceServer) GetCurrentAcquisitionRun(context.Context, *GetCurrentAcquisitionRunRequest) (*AcquisitionRunInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentAcquisitionRun not implemented")
}
func (UnimplementedAcquisitionServiceServer) SetSignalReader(context.Context, *SetSignalReaderRequest) (*SetSignalReaderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSignalReader not implemented")
}
func (UnimplementedAcquisitionServiceServer) mustEmbedUnimplementedAcquisitionServiceServer() {}

// UnsafeAcquisitionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AcquisitionServiceServer will
// result in compilation errors.
type UnsafeAcquisitionServiceServer interface {
	mustEmbedUnimplementedAcquisitionServiceServer()
}

func RegisterAcquisitionServiceServer(s grpc.ServiceRegistrar, srv AcquisitionServiceServer) {
	s.RegisterService(&AcquisitionService_ServiceDesc, srv)
}

func _AcquisitionService_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcquisitionServiceServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.acquisition.AcquisitionService/start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcquisitionServiceServer).Start(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcquisitionService_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcquisitionServiceServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.acquisition.AcquisitionService/stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcquisitionServiceServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcquisitionService_WatchForStatusChange_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AcquisitionServiceServer).WatchForStatusChange(&acquisitionServiceWatchForStatusChangeServer{stream})
}

type AcquisitionService_WatchForStatusChangeServer interface {
	Send(*WatchForStatusChangeResponse) error
	Recv() (*WatchForStatusChangeRequest, error)
	grpc.ServerStream
}

type acquisitionServiceWatchForStatusChangeServer struct {
	grpc.ServerStream
}

func (x *acquisitionServiceWatchForStatusChangeServer) Send(m *WatchForStatusChangeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *acquisitionServiceWatchForStatusChangeServer) Recv() (*WatchForStatusChangeRequest, error) {
	m := new(WatchForStatusChangeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AcquisitionService_WatchCurrentAcquisitionRun_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchCurrentAcquisitionRunRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AcquisitionServiceServer).WatchCurrentAcquisitionRun(m, &acquisitionServiceWatchCurrentAcquisitionRunServer{stream})
}

type AcquisitionService_WatchCurrentAcquisitionRunServer interface {
	Send(*AcquisitionRunInfo) error
	grpc.ServerStream
}

type acquisitionServiceWatchCurrentAcquisitionRunServer struct {
	grpc.ServerStream
}

func (x *acquisitionServiceWatchCurrentAcquisitionRunServer) Send(m *AcquisitionRunInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _AcquisitionService_CurrentStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CurrentStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcquisitionServiceServer).CurrentStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.acquisition.AcquisitionService/current_status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcquisitionServiceServer).CurrentStatus(ctx, req.(*CurrentStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcquisitionService_GetProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcquisitionServiceServer).GetProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.acquisition.AcquisitionService/get_progress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcquisitionServiceServer).GetProgress(ctx, req.(*GetProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcquisitionService_GetAcquisitionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAcquisitionRunInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcquisitionServiceServer).GetAcquisitionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.acquisition.AcquisitionService/get_acquisition_info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcquisitionServiceServer).GetAcquisitionInfo(ctx, req.(*GetAcquisitionRunInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcquisitionService_ListAcquisitionRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAcquisitionRunsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcquisitionServiceServer).ListAcquisitionRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.acquisition.AcquisitionService/list_acquisition_runs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcquisitionServiceServer).ListAcquisitionRuns(ctx, req.(*ListAcquisitionRunsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcquisitionService_GetCurrentAcquisitionRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentAcquisitionRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcquisitionServiceServer).GetCurrentAcquisitionRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.acquisition.AcquisitionService/get_current_acquisition_run",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcquisitionServiceServer).GetCurrentAcquisitionRun(ctx, req.(*GetCurrentAcquisitionRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcquisitionService_SetSignalReader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSignalReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcquisitionServiceServer).SetSignalReader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/minknow_api.acquisition.AcquisitionService/set_signal_reader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcquisitionServiceServer).SetSignalReader(ctx, req.(*SetSignalReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AcquisitionService_ServiceDesc is the grpc.ServiceDesc for AcquisitionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AcquisitionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "minknow_api.acquisition.AcquisitionService",
	HandlerType: (*AcquisitionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "start",
			Handler:    _AcquisitionService_Start_Handler,
		},
		{
			MethodName: "stop",
			Handler:    _AcquisitionService_Stop_Handler,
		},
		{
			MethodName: "current_status",
			Handler:    _AcquisitionService_CurrentStatus_Handler,
		},
		{
			MethodName: "get_progress",
			Handler:    _AcquisitionService_GetProgress_Handler,
		},
		{
			MethodName: "get_acquisition_info",
			Handler:    _AcquisitionService_GetAcquisitionInfo_Handler,
		},
		{
			MethodName: "list_acquisition_runs",
			Handler:    _AcquisitionService_ListAcquisitionRuns_Handler,
		},
		{
			MethodName: "get_current_acquisition_run",
			Handler:    _AcquisitionService_GetCurrentAcquisitionRun_Handler,
		},
		{
			MethodName: "set_signal_reader",
			Handler:    _AcquisitionService_SetSignalReader_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "watch_for_status_change",
			Handler:       _AcquisitionService_WatchForStatusChange_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "watch_current_acquisition_run",
			Handler:       _AcquisitionService_WatchCurrentAcquisitionRun_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "minknow_api/acquisition.proto",
}
